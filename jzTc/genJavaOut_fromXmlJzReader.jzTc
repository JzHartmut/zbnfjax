##This script reads a zbnf syntax script and generates a proper java output file for 
##It should be included as subscript
##template for calling script and necessary script variables:

include zbnfjax/jzTc/genJavaOut.jzTc;

String javaDir = "path/to/Javafiles";
String pkgpath = "my.package.path";
String javaclass = "MyJavaOutput";



==JZtxtcmd==

##set the text output for this script:
##
text = <:><&javaDir>/<&pkgpath.replace(".","/")>/<&javaclass>.java<.>;


sub writeRootClassFromXmlCfg( Obj xmlCfg, String javaDir, String pkgpath, String javaclass)
{

  test.dataHtml(xmlCfg, File: T:/test.html);
  <:>
==package <&pkgpath>;
==
==import java.util.ArrayList;
==import java.util.List;
==
==/**This file is generated by genJavaOut_fromXmlJzReader.jzTc script. */
==public class <&javaclass> {
  <.>
  ##
  for(subtree:xmlCfg.subtrees) { ##all stored subtree definition
      String sIndent = "  ";
      <+out><&subtree.tag><.+n>                                        
      call writeDstClass( subclass=subtree, className = subtree.tag);   
      call writeSubClasses( parent=subtree, indent = 4);   
  }
  call writeSubClasses(parent = xmlCfg.rootNode, indent=2);
  <:>  
  }   
  <.>
  <+out>successfull<.+>
  
  
}

  
String spaces = "                                                           ";

sub writeDstClass(Obj subclass, String className){
  <:>
==  public static class <&className> {
  <.>
  for(attrib: subclass.attribs){
    <:>
====    public String <&attrib.storeInMap>;
    <.>
  }
  <:>
==    /**Constructor with attrib values. */  
==    public <&className>(<:for:attrib: subclass.attribs>String <&attrib.storeInMap><:hasNext>, <.hasNext><.for>) {<.>
  for(attrib: subclass.attribs){
    <:>
====      this.<&attrib.storeInMap> = <&attrib.storeInMap>;<.>
  }
  <:>
==    }
  <.>
  for(subnode: subclass.subnodes) {
    if(subnode.dstClassName) {
    <:>
====    public void add_<&subnode.dstClassName>(<: >
         <:for:arg:subnode.elementStorePath.argNames>String <&arg><:hasNext>, <.hasNext><.for>) {
====    }
    <.>
    }
  }##for subnodes
  <:>
==  }
  <.>
}
    



sub writeSubClasses(Obj parent, Num indent) {
  String sIndent = spaces.substring(0, indent);
  for(subclass: parent.subnodes) {
    if(subclass.cfgSubtreeName == null && subclass.dstClassName) {  ##xmlinput:subtree already processed.
      <+out><&subclass.tag><.+n>                                        
      call writeDstClass(subclass=subclass, className = subclass.dstClassName);      
      call writeSubClasses( parent=subclass, indent = indent);   
    }
  }
}





