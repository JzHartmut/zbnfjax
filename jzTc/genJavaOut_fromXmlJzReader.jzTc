##This script reads a zbnf syntax script and generates a proper java output file for 
##It should be included as subscript
##template for calling script and necessary script variables:

include zbnfjax/jzTc/genJavaOut.jzTc;

String javaDir = "path/to/Javafiles";
String pkgpath = "my.package.path";
String javaclass = "MyJavaOutput";



==JZtxtcmd==



sub writeRootClassFromXmlCfg( Obj xmlCfg, String javaDir, String pkgpath, String javaclass)
{
  ##set the text output for this sub routine and call sub:
  ##
  text = <:><&javaDir>/<&pkgpath.replace(".","/")>/<&javaclass>.java<.>;

  test.dataHtml(xmlCfg, File: T:/test.html);
  <:>
==package <&pkgpath>;
==
==import java.util.ArrayList;
==import java.util.List;
==
==/**This file is generated by genJavaOut_fromXmlJzReader.jzTc script. */
==public class <&javaclass> {
  <.>
  ##
  for(subtree:xmlCfg.subtrees) { ##all stored subtree definition
      String sIndent = "  ";
      <+out><&subtree.tag><.+n>                                        
      <:>
======  /**Subclass defined in XML config-subtree. */      
======  public static class <&subtree.dstClassName> {
      <.>
      call writeClassContent( subclass=subtree, className = subtree.tag);   
      <:>
======  } //class <&subtree.dstClassName>
      <.>
      call writeSubClasses( parent=subtree, indent = 4);   
  }
  call writeSubClasses(parent = xmlCfg.rootNode, indent=2);
  ##
  call writeClassContent( subclass=xmlCfg.rootNode, className = javaclass);   
  <:>  
  }   
  <.>
  <+out>successfull<.+>
  
  
}

  
String spaces = "                                                           ";

sub writeClassContent(Obj subclass, String className){
  for(attrib: subclass.attribs){
    <:>
====    /** XML attrib @<&attrib.storeInMap>> */    
====    public String <&attrib.storeInMap>;  //from attrib storeInMap
    <.>
  }
  for(subnode: subclass.subnodes) {
    if(subnode.dstClassName) {
      if(subnode.elementStorePath.ident >= "set_") {
        <:>
========    /** XML tag=<&subnode.tag> */        
========    <&subnode.dstClassName> <&subnode.dstClassName>;            
        <.>
      } elsif(subnode.elementStorePath.ident >= "add_") {
        <:>
========    /** XML tag=<&subnode.tag> */        
========    List<<&subnode.dstClassName>> <&subnode.dstClassName> = new ArrayList<<&subnode.dstClassName>>();            
        <.>  
      } else {
        <:>
========    //ERROR unexpected: no add, no set: <&subnode.dstClassName>        
        <.>
      }  
    } elsif(subnode.elementStorePath) { ##a subnode without dstClass, should store content immediately:
      if(subnode.elementStorePath.ident >= "set_") {
        for(arg: subnode.elementStorePath.argNames) {
          <:>
==========    /** XML tag=<&subnode.tag>/@<&arg> */        
==========    String <&subnode.tag>_<&arg>;            
          <.>
        }
      } elsif(subnode.elementStorePath.ident >= "add_") {
        String secondArg = "";
        for(arg: subnode.elementStorePath.argNames) {
          <:>
==========    /** XML tag=<&subnode.tag>/@<&arg> */        
==========    List<String> <&subnode.tag>_<&arg> = new ArrayList<String>();  <&secondArg>            
          <.>
          secondArg = "//ERROR only one arg for add possible";
        }
      } else {
        <:>
========    //ERROR unexpected: no add, no set: <&subnode.dstClassName>        
        <.>
      }  
       
    } elsif(subnode.contentStorePath) {
      <:>
======    /** XML tag=<&subnode.tag>/text() */        
======    String <&subnode.tag>_text;            
      <.>
    }
  }##for subnodes
  ##
  <:>
==    /**Constructor with attrib values. */  
==    public <&className>(<:for:attrib: subclass.attribs>String <&attrib.storeInMap><:hasNext>, <.hasNext><.for>) {<.>
  for(attrib: subclass.attribs){
    <:>
====      this.<&attrib.storeInMap> = <&attrib.storeInMap>;  //from attrib storeInMap<.>
  }
  <:>
==    }
  <.>
  for(subnode: subclass.subnodes) {
    if(subnode.dstClassName) {
    <:>
====    /**Invoked from XMLjzReader cfg.xml to create an instance for the content of the &lt;<&subnode.tag> ... &gt;
====     * The attributes of the XML element are used as String arguments.
====     */
====    public <&subnode.dstClassName> <&subnode.elementStorePath.ident> (<: >
         <:for:arg:subnode.elementStorePath.argNames>String <&arg><:hasNext>, <.hasNext><.for>) {
====      <&subnode.dstClassName> obj = new <&subnode.dstClassName>(<:for:arg:subnode.elementStorePath.argNames><&arg><:hasNext>, <.hasNext><.for>);<.>
    if(subnode.elementStorePath.ident>="set_"){
      <:>
======      this.<&subnode.dstClassName> = obj;<.>
    } else {
      <:>
======      this.<&subnode.dstClassName>.add(obj);<.>
    }
    <:>  
====      return obj;
====    }
    <.>
    } elsif(subnode.elementStorePath) {
      call writeAttrSetRoutine(storePath = subnode.elementStorePath, subtag=subnode.tag);
    } elsif(subnode.contentStorePath) {
      call writeAttrSetRoutine(storePath = subnode.contentStorePath, subtag=subnode.tag);
    }
  }##for subnodes
}
    



sub writeAttrSetRoutine(Obj storePath, String subtag) {
              <:>
==============    /**Invoked from XMLjzReader cfg.xml to store the attribute values of the &lt;<&subtag> ... &gt;
==============     * The attributes of the XML element are used as String arguments.
==============     */
==============    public void <&storePath.ident> (<:for:arg:storePath.argNames>String <&arg><:hasNext>, <.hasNext><.for>) { <.>
  for(arg: storePath.argNames){
    if(storePath.ident >= "set_"){
              <:>
==============      this.<&subtag>_<&arg> = <&arg>;<.>
    } else {
              <:>
==============      this.<&subtag>_<&arg>.add(<&arg>);   //more as one element<.>
    }     
  }
              <:> 
==============    }
    <.>
}












sub writeSubClasses(Obj parent, Num indent) {
  String sIndent = spaces.substring(0, indent);
  for(subclass: parent.subnodes) {
    if(subclass.cfgSubtreeName == null && subclass.dstClassName) {  ##xmlinput:subtree already processed.
      <+out><&subclass.tag><.+n>                                        
      <:>
======  /**Subclass from an inner node list in defined in <&parent.tag> in the XML config-subtree. */      
======  public static class <&subclass.dstClassName> {
      <.>
      call writeClassContent(subclass=subclass, className = subclass.dstClassName);      
      <:>
======  } //subclass <&subclass.dstClassName>
      <.>
      
      call writeSubClasses( parent=subclass, indent = indent);   
    }
  }
}





