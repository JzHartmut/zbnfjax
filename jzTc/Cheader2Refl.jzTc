##jzTc script to generate a Reflection.crefl file from some struct of Header.
##made by Hartmut Schorrig,  



Map reflSimpleTypes = {
  String int = "REFLECTION_int32";
  String uint32_t = "REFLECTION_uint32";
  String uint32 = "REFLECTION_uint32";
  String int32_t = "REFLECTION_int32";
  String int32 = "REFLECTION_int32";
  String int16_t = "REFLECTION_int16";
  String float = "REFLECTION_float";
  String double = "REFLECTION_double";
};  

    
sub genReflFileStruct(String dirRefl, Obj struct, String headerName) 
{
  String fileRefl = <:><&dirRefl>/<&struct.name>_crefl.c<.>;
  Openfile outRefl = fileRefl;
  <+outRefl>
  //This file is generated by zbnfjax/jzTc/GenRefl.jzTc
  #include <<&headerName>>
  #include <Jc/ReflectionJc.h>
  #include <stddef.h>
  <:call:genReflStruct:struct=struct>
  <.+close>
}


                   
sub genReflStruct(Obj struct) 
{ Num nrElements = 0;
  for(entry:struct.entries){if(entry.name) {
    nrElements = nrElements +1;
  } }
  <:>
==
==extern_C const ClassJc reflection_<&struct.name>;  //the just defined reflection_ used in the own fields.
  <.>
  for(entry:struct.entries) { if(entry.name && entry.type) { ##Note a type is not present for a #define inside a struct.
    String typeRefl;
    if(not reflSimpleTypes.get(entry.type.name)) { 
      <:>
======extern_C const ClassJc reflection_<&entry.type.name>;  //used for field <&entry.name><.>      
    }
  }}
  <:>  
==
==const struct Reflection_Fields_<&struct.name>_t
=={ ObjectArrayJc head;
==  FieldJc data[<&struct.entries.size>];
==} reflection_Fields_<&struct.name> =
=={ CONST_ObjectArrayJc(FieldJc, <&nrElements>, OBJTYPE_FieldJc, null, &reflection_Fields_<&struct.name>)
==, { <.>
  for(entry:struct.entries){ if(entry.name) {
    String typeRefl;
    String modifier = "0";
    if(entry.type.pointer){ modifier = "kReference_Modifier_reflectJc"; }  ##reference type, from primitive or class type. 
    if(entry.macro == "OS_HandlePtr") {  ##special macro for bus - handle
      typeRefl = <:>&reflection_<&entry.type.name><.>;
      modifier = "kHandlePtr_Modifier_reflectJc | kReference_Modifier_reflectJc";
    } elsif(entry.type) {  
      typeRefl = reflSimpleTypes.get(entry.type.name);
      if(!typeRefl) { typeRefl = <:>&reflection_<&entry.type.name><.>; }
    } else {
      //another macro is ignored.
    }
    String arraysize;
    if(entry.arraysize.value) {
      arraysize = <:><&entry.arraysize.value> //array<.>;
      modifier = <:><&modifier> | kStaticArray_Modifier_reflectJc<.>;
    } else {
      arraysize = "0   //no Array, no Bitfield";
    }
    <:><:indent:2=><: >
      { "<&entry.name>"
====    , <&arraysize>
====    , <&typeRefl>
====    , <&modifier>
====    , (int16)((int32)(&((<&struct.name>*)(0x1000))-><&entry.name>) -(int32)(<&struct.name>*)0x1000)
====    , 0  //offsetToObjectifcBase
====    , &reflection_<&struct.name>
====    }
====  <:hasNext>, <.hasNext><: >
    <.>
  } } //if for
  <:>  
==} };
==
==const ClassJc reflection_<&struct.name> =
=={ CONST_ObjectJc(OBJTYPE_ClassJc + sizeof(ClassJc), &reflection_<&struct.name>, &reflection_ClassJc)
==, "<&struct.name>"
==, 0
==, sizeof(<&struct.name>)
==, (FieldJcArray const*)&reflection_Fields_<&struct.name>  //attributes and associations
==, null  //method
==, null  //superclass
==, null  //interfaces
==, 0 
==};
==
==<.>
}




##
##The routine to generate reflection files, one file per header file.
##It parses all header files one after another, then generates reflection
##
sub genReflection(Obj target: org.vishia.cmd.ZmakeTarget, String html = null)
{
  Obj headerTranslator = java new org.vishia.header2Reflection.CheaderParser(console);

  List inputsExpanded = target.allInputFilesExpanded();
  for(input:inputsExpanded)
  { ##java org.vishia.util.DataAccess.debugMethod("setSrc");
    Obj args = java new org.vishia.header2Reflection.CheaderParser$Args();
    args.addSrc(input.absfile(), input.namext());
  
    args.setDst(target.output.absfile());
    
    args.setZbnfHeader(<:><&scriptdir>/../zbnf/Cheader.zbnf<.>);
    
    
    Obj headers = headerTranslator.execute(args);
  
    ##Only to help change the script, output all parsed data:
    if(html !=null) {
      test.dataHtml(headers, File:<:><&target.output.globaldir()>/<&html><.>);
    }
  
    for(headerfile: headers.files){
      <+out>generate <&headerfile.fileName> <.+n>
      String fileRefl = <:><&target.output.absdir()>/<&headerfile.fileName>_crefl.c<.>;
      Openfile outRefl = fileRefl;
        <+outRefl>
        <:>
========//This file is generated by ZBNF/zbnfjax/jzTc/Cheader2Refl.jzTc
========#include <<&headerfile.fileName>>
========#include <Jc/ReflectionJc.h>
========#include <stddef.h>
        <.><.+>
      for(classC: headerfile.listClassC) {
        for(entry: classC.entries) {
          if(entry.whatisit == "structDefinition") {
            ##
            ##check whether a Bus should be generated.
            ##
            <+outRefl><:call:genReflStruct:struct=entry, headerName = &headerfile.fileName><.+>
          }
          if(entry.whatisit == "unionDefinition") {
            <+>  union <.n+>
            for(variant: entry.listVariantes) {
              if(variant.struct) {
                <+>  :struct <&variant.struct.tagname>  <.+n>
                
              }
            }
          }
        }
      
      }
      outRefl.close();
    }
  }
}
