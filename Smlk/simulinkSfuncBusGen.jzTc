##jzTc script to generate a matlab .m-File to generate a some buses from Header.
##made by Hartmut Schorrig,  

##include simulinkSfunc.jztxt;
include simulinkSfuncHandle.jzTc;
include simulink_tlc_SfH.jzTc;
include ../jzTc/Cheader2Refl.jzTc;
##include simulinkSfuncObjectJcPtr.jzTc;

##
##stores all information about header files which are converted to buses.
##
Map allBuses;

##Java classes for check.
Class zbnfStructDefinition = org.vishia.header2Reflection.CheaderParser$StructDefinition;
Class ZbnfMethodDefinition = org.vishia.header2Reflection.CheaderParser$MethodDef;

##
##assignment between types in C and the matlab types in the bus.
##
Map matlabTypes = {
  String int = "int32";
  String uint32_t = "uint32";
  String uint32 = "uint32";
  String int32_t = "int32";
  String int32 = "int32";
  String int16_t = "int16";
  String float = "single";
  String float_complex = "single";
  String double = "double";
  String double_complex = "double";
  String SIMUPTR = "double";
};  

Map matlabComplexity = {
  String int = "real";
  String uint32_t = "real";
  String uint32 = "real";
  String int32_t = "real";
  String int32 = "real";
  String int16_t = "real";
  String float = "real";
  String float_complex = "complex";
  String double = "real";
  String double_complex = "complex";
  String SIMUPTR = "real";
};  

##
##assignment between types in C and the matlab types in the Sfunc.
##
Map SfuncTypes = {
  String int = "SS_INT32";
  String uint32_t = "SS_UINT32";
  String uint32 = "SS_UINT32";
  String int32_t = "SS_INT32";
  String int32 = "SS_INT32";
  String int16_t = "SS_INT16";
  String float = "SS_SINGLE";
  String float_complex = "SS_SINGLE";
  String double = "SS_DOUBLE";
  String double_complex = "SS_DOUBLE";
  String SIMUPTR = "SS_DOUBLE";
};  

Map SfuncComplexity = {
  String int = "COMPLEX_NO";
  String uint32_t = "COMPLEX_NO";
  String uint32 = "COMPLEX_NO";
  String int32_t = "COMPLEX_NO";
  String int32 = "COMPLEX_NO";
  String int16_t = "COMPLEX_NO";
  String float = "COMPLEX_NO";
  String float_complex = "COMPLEX_YES";
  String double = "COMPLEX_NO";
  String double_complex = "COMPLEX_YES";
  String SIMUPTR = "COMPLEX_NO";
};  



##fileBus: directory path from targetoutput to bus m-file
##dirSfunc: directory path from targetoutput to sfunc.
sub simulinkSfuncBusGen(Obj target: org.vishia.cmd.ZmakeTarget, String fileBus = null, String dirSfunc = null, String dirRefl = null, String html = null)
{
  ## if the arguments starts with ":...." use the target.output.basepath:
  if(fileBus >= ":") { fileBus = <:><&target.output.basepath()>/<&fileBus.substring(1)><.>; }
  if(dirSfunc >= ":") { dirSfunc = <:><&target.output.basepath()>/<&dirSfunc.substring(1)><.>; }
  if(dirRefl >= ":") { dirRefl = <:><&target.output.basepath()>/<&dirRefl.substring(1)><.>; }
  if(html >= ":") { html = <:><&target.output.basepath()>/<&html.substring(1)><.>; }
  Obj headerTranslator = java new org.vishia.header2Reflection.CheaderParser(console);

  if(fileBus) {  ##write the head lines of the fileBus:
    Openfile bus_mscript = fileBus;
    <+bus_mscript><: >
      function <&target.output.name()> 
      % this script initializes a set of bus objects in the MATLAB base workspace 
      % generated by simulinkSfuncBusGen.jzcmd
      
      % The ObjectJc bus is included!
      ObjectJc_genBus();
    <.+>  
  }
  List inputsExpanded = target.allInputFilesExpanded();
  for(input:inputsExpanded)
  { ##java org.vishia.util.DataAccess.debugMethod("setSrc");
    Obj args = java new org.vishia.header2Reflection.CheaderParser$Args();
    args.addSrc(input.absfile(), input.namext());
  
    args.setDst(target.output.absfile());
    
    args.setZbnfHeader(<:><&scriptdir>/../zbnf/Cheader.zbnf<.>);
    
    
    Obj headers = headerTranslator.execute(args);
  
    ##Only to help change the script, output all parsed data:
    if(html !=null) {
      test.dataHtml(headers, File:<:><&html><&target.output.name()>.html<.>);
    }
    if(fileBus){ 
      if(dirSfunc) { 
        if(dirSfunc >= ":") { dirSfunc = <:><&target.output.basepath()>/<&dirSfunc.substring(1)><.>; }
      }
      call genBusGenScript(parseResult = headers, bus_mscript = bus_mscript, dirSfunc = dirSfunc, dirRefl = dirRefl, headerSrc = input, scriptname = target.output.name()); 
    }
    if(dirSfunc) { 
      call genSfuncHandleGenScript(parseResult = headers, sDirMex = dirSfunc, headerSrc = input); 
    }
  }
  if(bus_mscript){
    bus_mscript.close();
  }
}


##
##This script is executed for the whole parsed result. 
##It finds out struct and generates buses.m and Sfunctions for ObjectJcPtr.
##
sub genBusGenScript(Obj parseResult, Obj bus_mscript, String dirSfunc, String dirRefl, Filepath headerSrc, String scriptname)
{

  <+out>generate <&headerSrc> <.+n>

  for(headerfile: parseResult.files){
    for(classC: headerfile.listClassC) {
      for(entry: classC.entries) {
        if(entry.whatisit == "structDefinition") {
          ##
          ##check whether a Bus should be generated.
          ##
          if(entry.description.simulinkTag >= "bus" || entry.description.simulinkTag >= "ObjectJcPtr") {
            <+>== gen bus from <&entry.name> ==<.+n>
            call genBus1(struct=entry, bus_mscript = bus_mscript, headerName = &headerfile.fileName, scriptname = &scriptname);
            if(dirRefl){
              String fileRefl = <:><&dirRefl>/<&entry.name>_crefl.c<.>;
              Openfile outRefl = fileRefl;
              <+outRefl><:call:genReflFile:struct=entry, headerName = &headerfile.fileName><.+close>
            }
          } else {
            <+>== struct no bus: <&entry.name> ==<.+n>
          }
          ##
          ##Only if it is designated as ObjectJcPtr, generate an Sfunction to assemble a bus with referenced buses.
          ##
##          if(entry.description.simulinkTag >= "ObjectJcPtr") {
##            <+>== <&entry.name>: gen Sfunc for Bus with ObjectJc ==<.+n>
##            
##            
##            String file_cWrapper = <:><&dirSfunc>/src2/<&entry.name>_Sfunc.c<.>; 
##            <+out>generate Sfunc-wrapper: <&file_cWrapper><.+n>;
##            Openfile cWrapper = file_cWrapper;
##            <+cWrapper><:call:wrapperSfuncObjectJcPtr:zbnfStruct=entry, nameHeader=headerSrc.localfile()>
##            <.+close>
##            
##            String file_tlc = <:><&dirSfunc>/<&entry.name>_Sfunc.tlc<.>; 
##            <+out>generate tlc: <&file_tlc><.+n>;
##            Openfile tlc = file_tlc;
##            <+tlc>TEST##<:call:tlctext: zbnfOp=entry, nameHeader=headerSrc.localfile()>
##            <.+close>
##          }
        }
        if(entry.whatisit == "unionDefinition") {
          <+>  union <.n+>
          for(variant: entry.listVariantes) {
            if(variant.struct) {
              <+>  :struct <&variant.struct.tagname>  <.+n>
              if(variant.struct.description.simulinkTag >= "bus") {
                <+>== gen bus from <&variant.struct.tagname> ==<.+n>
                call genBus1(struct=variant.struct, bus_mscript = bus_mscript, headerName = &headerfile.fileName, scriptname = &scriptname);
                <+><.+n>
              } else {
                <+>== union no bus: <&entry.name> ==<.+n>
              }
            }
          }
        }
      }
    }
  }


}






##
##Generate the bus definition m-statements for one struct in the header file.
##
## arg struct: The found struct in parse result.
##
sub genBus1(Obj struct, Obj bus_mscript, String headerName, String scriptname)
{
  String name = &struct.name;
  if(NOT name) { name = &struct.tagname; } 
  Map elementsOfBus;
  List elementsOfBus;
  allBuses.put(name, elementsOfBus);
  <+bus_mscript>            
    % Bus object: <&name> 
    clear <&name>_elems;
    ix = 1;
  <.+>  
  for(entry1: struct.entries) {
    ##<+out><&test.info(entry1)><.n+>
    if(entry1.description.simulinkTag >= "stop") { 
      <+out>Simulink stop<.n+>  
      break; 
    }
    if(entry1.description.simulinkTag >= "hideElement") { ##NOTE: simulinkTag contains all whitespaces after hideElement too.
      ##<+out>hidden element <&entry1.name> <.+n>
    }
    elsif(entry1 ?instanceof zbnfStructDefinition) {
      if(entry1.name ==null) {
        if(entry1.isUnion) {
          Obj firstEntry = entry1.entries.get(0);  ##use the first entry of a union for the bus element. The other ones are accessible in C only.
          call genEntry(name = name, entry1 = firstEntry, elementsOfBus = elementsOfBus, bus_mscript = bus_mscript);
        }
        else { <+out>implicit unnamed struct not supported yet, only unnamed union: <&entry1.name><.n+> }
      }
      else { <+out>implicit named struct not supported yet: <&entry1.name><.n+> }
    }
    elsif(entry1.type) {
      call genEntry(name = name, entry1 = entry1, elementsOfBus = elementsOfBus, bus_mscript = bus_mscript);
    }
  }
  ##<+><.+n>
  <+bus_mscript>            
  <&name> = Simulink.Bus;
  <&name>.HeaderFile = '<&headerName>';
  <&name>.Description = 'Generated from simulinkBusGen.jzcmd from Headerfile <&headerName>, via script <&scriptname>.m';
  <&name>.DataScope = 'Imported';
  <&name>.Alignment = -1;
  <&name>.Elements = <&name>_elems;
  assignin('base','<&name>', <&name>);
  
  <.+>  

}





sub genEntry(String name, Obj entry1, List elementsOfBus, Obj bus_mscript) 
{
  ##<+><&entry1.name> <&entry1.type.name><.n+>
  //java org.vishia.util.DataAccess.debugIdent("matlabTypes");
  String complexity = &matlabComplexity.get(entry1.type.name);
  String type = &matlabTypes.get(entry1.type.name);
  Num arraySize = 1;
  if(entry1.arraysize) { arraySize = entry1.arraysize.value; }  //only constant values are supported yet.
  Map busTag;
  String busTag.name = entry1.name;
  String busTag.type = entry1.type;
  Num busTag.arraySize = arraySize;
  elementsOfBus += busTag;  ##add to List.
  if(entry1.type.pointer) {
    <+bus_mscript>
    <&name>_elems(ix) = Simulink.BusElement;
    <&name>_elems(ix).Name = '<&entry1.name>';
    <&name>_elems(ix).Dimensions = 2;
    <&name>_elems(ix).DimensionsMode = 'Fixed';
    <&name>_elems(ix).DataType = 'int32';  %pointer, define int32[2]
    <&name>_elems(ix).SampleTime = -1;
    <&name>_elems(ix).Complexity = 'real';
    <&name>_elems(ix).Description = 'pointer type, it is 2x32bit in PC environment.'; ##<&entry1.description.text>';
    <.+>
  }
  else {
    if(not type) {
      ##<+err>unknown type <&entry1.type.name><.n+>
      ##type = "int32";
      type = <:>Bus: <&entry1.type.name><.>;  //all other types are a bus, a pointer in the header.
      complexity = "real";
    }
    if(not complexity) {
      complexity = "real";
    }
    <+bus_mscript>
    <&name>_elems(ix) = Simulink.BusElement;
    <&name>_elems(ix).Name = '<&entry1.name>';
    <&name>_elems(ix).Dimensions = <&arraySize>;
    <&name>_elems(ix).DimensionsMode = 'Fixed';
    <&name>_elems(ix).DataType = '<&type>';
    <&name>_elems(ix).SampleTime = -1;
    <&name>_elems(ix).Complexity = '<&complexity>';
    <&name>_elems(ix).Description = 'TODO description from header in one line. '; ##<&entry1.description.text>';
    <.+>
  }
  <+bus_mscript>
  <&name>_elems(ix).SamplingMode = 'Sample based';
  <&name>_elems(ix).Min = [];
  <&name>_elems(ix).Max = [];
  <&name>_elems(ix).DocUnits = '';
  ##<&name>_elems(ix).Description = '<&java org.vishia.util.StringFunctions_B.firstLine(entry1.description.text)>';
  
  ix = ix+1;
  <.+>

}






sub XXXXXXXXXXXXgenSfuncGenScript(Obj parseResult, String sDirMex, Filepath headerSrc)
{

  for(headerfile: parseResult.files){
    for(classC: headerfile.listClassC) {
      Obj zbnfCtor; 
      for(entry: classC.entries) {
        if(entry ?instanceof ZbnfMethodDefinition && entry.description.simulinkTag >= "Sfunc") { 
          if(entry.name >= "ctor_") {
            zbnfCtor = entry;
          } else {
            String file_cWrapper = <:><&sDirMex>/src2/<&entry.name>_Sfunc.c<.>; 
            <+out>generate Sfunc-wrapper: <&file_cWrapper><.+n>;
            Openfile cWrapper = file_cWrapper;
            call wrapperCgen(wrapperFilec = cWrapper, zbnfOp=entry, zbnfCtor = zbnfCtor, nameHeader=headerSrc.localfile());  
            cWrapper.close();
  
            String file_tlc = <:><&sDirMex>/<&entry.name>_Sfunc.tlc<.>; 
            <+out>generate tlc: <&file_tlc><.+n>;
            Openfile tlc = file_tlc;
            <+tlc><:call:tlctext: zbnfOp=entry, zbnfCtor=zbnfCtor, nameHeader=headerSrc.localfile()>
            <.+close>
            zbnfCtor = null;  //used.
          }
        }
      }
    }
  }


}

sub genSfuncHandleGenScript(Obj parseResult, String sDirMex, Filepath headerSrc)
{

  String file_mMex = <:><&sDirMex>/genXYZ.m<.>; 
  <+out>generate m-File to compile: <&file_mMex><.+n>;
  Openfile mMex = file_mMex;
  <+mMex>%Matlab m-file xxx
  <.+>
  for(headerfile: parseResult.files){
    for(classC: headerfile.listClassC) {
      Obj zbnfCtor; 
      for(entry: classC.entries) {
        if(entry ?instanceof ZbnfMethodDefinition && entry.description.simulinkTag >= "Sfunc") { 
          if(entry.name >= "ctor_") {
            zbnfCtor = entry;
          } else {
            String file_cWrapper = <:><&sDirMex>/src2/<&entry.name>_SfH.c<.>; 
            <+out>generate Sfunc-wrapper: <&file_cWrapper><.+n>;
            Openfile cWrapper = file_cWrapper;
            call wrapperCgenHandle(wrapperFilec = cWrapper, zbnfOp=entry, zbnfCtor = zbnfCtor, nameHeader=headerSrc.localfile());  
            cWrapper.close();
            <+mMex>
            <:call:genmex:header = headerSrc, zbnfOp=entry>
            <.+>
            
            String file_tlc = <:><&sDirMex>/<&entry.name>_SfH.tlc<.>; 
            <+out>generate tlc: <&file_tlc><.+n>;
            Openfile tlc = file_tlc;
            <+tlc><:call:tlctext: zbnfOp=entry, zbnfCtor = zbnfCtor, nameHeader=headerSrc.localfile()>
            <.+close>
            zbnfCtor = null;  //used.
          }
        }
      }
    }
  }

  mMex.close();
}



