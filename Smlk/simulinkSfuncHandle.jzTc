##jzTc script to generate a wrapper.c-File to generate S-Functions.
##for functions from a parsed Header file.
##made by Hartmut Schorrig,  
##Note: new name is jzTc for Java-Zbnf-Text-Command language. Old name is JZcmd. 
##Syntax see www.vishia.org/ZBNF/sf/docu/JZcmd.html 

##find:
##--- mdlInitializeSizes(SimStruct *S) ---
## initDworkBusInfoHandle initializing of Dwork 
## initPortsHandle  initializing of all ports 
##---mdlInitializeConditions(SimStruct *S)
##sub genCtorHandle
##---mdlStart(SimStruct *S)
##sub setBusInfo_mdlStartHandle(                                  
##--- mdlOutputs(SimStruct *S, int_T tid) ---
## genSfH_stepFnH  the step content


##
##Sub routine to generate the wrapper c-file for a S-function from the given header and operation in the header.
##Argument zbnfOp is from CHeader.zbnf parsed via ZBNF, syntax component 'methodDef::='.
##Argument zbnfCtor may be null, or the ctor before the operation in the header, syntax component 'methodDef::='.
##
##The text generation environment.
##
sub wrapperCgenHandle(Obj wrapperFilec, Obj zbnfOp, Obj zbnfCtor, String nameHeader)
{
  <+wrapperFilec><:subtext:wrapperCHandle><.+>
  
}

##
##Sub routine to generate the wrapper c-file for a S-function from the given header and operation in the header.
##Argument zbnfOp is from CHeader.zbnf parsed via ZBNF, syntax component 'methodDef::='.
##Argument zbnfCtor may be null, or the ctor before the operation in the header, syntax component 'methodDef::='.
##
sub wrapperCHandle(use-locals) {
Num nrSampleTimes = 1;
String genTstepDef = "Tstep = 0.020/256; ";
<:>
/*
 * <&zbnfOp.name>.c C-MEX S-function wrapper.
 *
 *
 * THIS S-FUNCTION IS GENERATED BY jzTc script ".../zbnfjax/Smlk/simulinkSFuncHandle.jzTc" DO NOT MODIFY
 */

/**Must specify the S_FUNCTION_NAME as the name of the S-function.
 */
#define S_FUNCTION_NAME                <&zbnfOp.name>_SfH
#define S_FUNCTION_LEVEL               2

/*
 * Need to include simstruc.h for the definition of the SimStruct and
 * its associated macro definitions.
 */
#include "simstruc.h"
#include <string.h>  //memset, strcmp
#include <stdlib.h>  //malloc
#include <Fwc/objectBaseC.h>   //The ObjectJc is used as base class for all struct
#include <OSAL/os_sharedmem.h> //Support 64-bit-pointer
/*
 * Specific header file(s) required by the S-function.
 */
#include "<&nameHeader>"


/*
 * Code Generation Environment flag (simulation or standalone target).
 */
##some stuff from original Mathworks Simulink S-function templates: 
static int_T isSimulationTarget;

#define EDIT_OK(S, P_IDX) \
 (!((ssGetSimMode(S)==SS_SIMMODE_SIZES_CALL_ONLY) && mxIsEmpty(ssGetSFcnParam(S, P_IDX))))
//#define SAMPLE_TIME                    (ssGetSFcnParam(S, 0))
#define isDWorkNeeded(S)               ((!((ssRTWGenIsCodeGen(S) || ssGetSimMode(S)==SS_SIMMODE_EXTERNAL) && isSimulationTarget==0)) || ssIsRapidAcceleratorActive(S))

/*
 * Utility function prototypes.
 */
//static bool IsRealMatrix(const mxArray *m);
static void CheckDataTypes(SimStruct *S);
static int_T GetRTWEnvironmentMode(SimStruct *S);

##Check the parameter only if the FB has a ctor, only the ctor takes parameter. TODO: parameter arguments for other operations.
<:if:zbnfCtor><:call:mdlCheckParamsHandle><.if>
<:-comment>
//should be comment?
<.-comment>

//If set, this is the found step time from Global Workspace Tinit.
static double Tinit = 0.1;  //This value is set from a global Workspace variable with name 'Tinit'. It should be existing.

static int nrofInputPorts =0, nrofOutputPorts =0, nrofParams =0;

/* Function: mdlInitializeSizes ===========================================
 * Abstract:
 *    The sizes information is used by Simulink to determine the S-function
 *    block's characteristics (number of inputs, outputs, states, etc.).
 */
static void mdlInitializeSizes(SimStruct *S)
{
  double Tstep = 0.020/256;

  ##stuff from original Mathworks Simulink S-function templates: 
  /*
   * Get the value returned by rtwenvironmentmode(modelName)
   */
  if (ssRTWGenIsCodeGen(S) || ssGetSimMode(S)==SS_SIMMODE_EXTERNAL) {
    isSimulationTarget = GetRTWEnvironmentMode(S);
    if (isSimulationTarget==-1) {
      ssSetErrorStatus(S,
                       "Unable to determine a valid code generation environment mode.");
      return;
    }

    isSimulationTarget |= ssRTWGenIsModelReferenceSimTarget(S);
  }

  ##generates code for ssSetNumSFcnParams(...)
  <:call:gen_checkParametersHandle>

#if defined(MATLAB_MEX_FILE)

  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {
    /*
     * If the number of expected input parameters is not equal
     * to the number of parameters entered in the dialog box return.
     * Simulink will generate an error indicating that there is a
     * parameter mismatch.
     */
    //TODO necessary?
    //mdlCheckParameters(S);
    if (ssGetErrorStatus(S) != NULL) {
      return;
    }
  } else {
    /* Return if number of expected != number of actual parameters */
    return;
  }

#endif

  ssSetNumPWork(S, 0);
  
  <:call:initDworkBusInfoHandle>
  
  //This should be set true, because all FBs can be used as multiple instances.
  ssSupportsMultipleExecInstances(S, true);


<.>
  ##Note: jzTc script, not source text:
  if(zbnfCtor) {
    ##Search whether the S-Func is build with a ctor, and the ctor has a Parameter named Tstep.
    ##Then use its value for the second sample time.
    Num ixParam=0;
    for(arg:zbnfCtor.args) {
      if(arg.name == "Tstep") {
        genTstepDef =
        <:>
        //jzTc: get Tstep Parameter value
        { const mxArray* Tstepp = ssGetSFcnParam(S, <&ixParam>);  //Tstep
          Tstep = *mxGetPr(Tstepp);  //assume Parameter is double, get the double (real_T)
        }
        <.>;
      }
      if(arg.name != "thiz") {
        ixParam = ixParam +1;
      }
  } }
<:>
  <&genTstepDef>
  
  ##Routine for all ports.
  <:call:initPortsHandle>

  /*
   * Register reserved identifiers to avoid name conflict
   */
  if (ssRTWGenIsCodeGen(S) || ssGetSimMode(S)==SS_SIMMODE_EXTERNAL) {
    /*
     * Register reserved identifier for InitializeConditionsFcnSpec
     */
    //it seems to be not necessary, the S-functions works proper.
    //ssRegMdlInfo(S, "ctor_Orthi_FB", MDL_INFO_ID_RESERVED, 0, 0, ssGetPath(S));
  }

  /*
   * This S-function can be used in referenced model simulating in normal mode.
   */
  ssSetModelReferenceNormalModeSupport(S, MDL_START_AND_MDL_PROCESS_PARAMS_OK);

  //The sample times should be port based. The handle ports are associated to Tinit. 
  //ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES); 
  ssSetNumSampleTimes(S, <&nrSampleTimes>);  //that requires mdlInitializeSampleTimes(...)
  /*
   * Set the compliance with the SimState feature.
   */
  ssSetSimStateCompliance(S, USE_DEFAULT_SIM_STATE);

  /*
   * All options have the form SS_OPTION_<name> and are documented in
   * matlabroot/simulink/include/simstruc.h. The options should be
   * bitwise or'd together as in
   *   ssSetOptions(S, (SS_OPTION_name1 | SS_OPTION_name2))
   */
  ssSetOptions( S,
                SS_OPTION_USE_TLC_WITH_ACCELERATOR |
                SS_OPTION_CAN_BE_CALLED_CONDITIONALLY |
                SS_OPTION_EXCEPTION_FREE_CODE |
                SS_OPTION_WORKS_WITH_CODE_REUSE |
                SS_OPTION_SFUNCTION_INLINED_FOR_RTW |
                SS_OPTION_DISALLOW_CONSTANT_SAMPLE_TIME
              | SS_OPTION_PORT_SAMPLE_TIMES_ASSIGNED);

#if defined(MATLAB_MEX_FILE)

  if ((ssGetSimMode(S)!=SS_SIMMODE_SIZES_CALL_ONLY) && !ssRTWGenIsCodeGen(S)) {
    /* Verify Data Type consistency with specification */
    CheckDataTypes(S);
  }

#endif

  //TODO necessary ? ssSetSimulinkVersionGeneratedIn(S, "8.7");
}







//#define MDL_INITIALIZE_SAMPLE_TIMES
/* Function: mdlInitializeSampleTimes =====================================
 * Abstract:
 *    This function is used to specify the sample time(s) for your
 *    S-function. You must register the same number of sample times as
 *    specified in ssSetNumSampleTimes.
 */
static void mdlInitializeSampleTimes(SimStruct *S)
{
  //not in diaglog: real_T * sampleTime = (real_T*) (mxGetPr(SAMPLE_TIME));  
  //mwSize stArraySize = mxGetM(SAMPLE_TIME) * mxGetN(SAMPLE_TIME);
  double Tstep;
  <&genTstepDef>

  int ix;
  //Check all input ports whether there sample time is known.
  //Note: the sample time is not known in test, whats happen?
  for(ix = 0; ix < nrofInputPorts; ++ix) {
    double time = ssGetInputPortSampleTime(S, ix);
    if(time == Tinit){ }
    else if(Tstep == -1) { Tstep = time; }
    else if(time != Tstep) {
      //a second time, warning
    }
    else {} //time is known already.
  }
  <:if:nrSampleTimes ?gt 1>
    //Initialize Tinit if Tinit is used.
    ssSetSampleTime(S, 0, Tinit) ; 
    ssSetOffsetTime(S, 0, 0) ;
    if(Tstep >0) { //given
      ssSetSampleTime(S, 1, Tstep) ;
      ssSetOffsetTime(S, 1, 0) ;
    } else {
      //don't initialize the 2. sample time. 
      //Simulink does not accept INHERITED_SAMPLE_TIME
      //if more as one sample time is used.
    }
  <:else>  
    if(Tstep >0) { //given
      ssSetSampleTime(S, 1, Tstep) ;
      ssSetOffsetTime(S, 1, 0) ;  //FIXED_IN_MINOR_STEP_OFFSET) ;
    } else {
      //Only one sample time. then INHERITED_SAMPLE_TIME is accepted:
      ssSetSampleTime(S, 1, INHERITED_SAMPLE_TIME) ;
      ssSetOffsetTime(S, 1, 0) ;
    }
  <.if>

#if defined(ssSetModelReferenceSampleTimeDefaultInheritance)

  ssSetModelReferenceSampleTimeDefaultInheritance(S);

#endif

}







#define MDL_SET_WORK_WIDTHS
#if defined(MDL_SET_WORK_WIDTHS) && defined(MATLAB_MEX_FILE)

/* Function: mdlSetWorkWidths =============================================
 * Abstract:
 *      The optional method, mdlSetWorkWidths is called after input port
 *      width, output port width, and sample times of the S-function have
 *      been determined to set any state and work vector sizes which are
 *      a function of the input, output, and/or sample times.
 *
 *      Run-time parameters are registered in this method using methods
 *      ssSetNumRunTimeParams, ssSetRunTimeParamInfo, and related methods.
 */
static void mdlSetWorkWidths(SimStruct *S)
{
  ##TODO parameters for non-ctor operations...
  <:if:zbnfCtor><:call:setRuntimeParamsHandle><.if>

  ssSupportsMultipleExecInstances(S, true);
}

#endif






/**This is the association table from handle to a 64-bit-memory address.
 * The instance of this type is present via shared memory in any S-function which uses this system.
 */
typedef struct Handle2Ptr_t{
  uint32 ixEnd; uint32 size;
  void* ptr[100];  //The size of the array is greater, adequate allocated shared memory.
} Handle2Ptr;



/**This pointer will be set with the shared memory address.
 */
static Handle2Ptr* handle2Ptr = null;



/**The length of the shared memory in byte. */
//TODO variable size of the Ptr2Handle via parameter or Simulink-Global variable. Then calculate it. The 1000 is any number.
static int32 length_Handle2Ptr = (1000-100) * sizeof(void*) + sizeof(Handle2Ptr);


/**Organization structure for the shared memory. */
static SharedMem_OSAL shMemHandle2Ptr = { 0};



/**Invoked after gotten shared memory, only the first caller should initialize it.
 */
static void init_Handle2Ptr(int32 size) {
  handle2Ptr->size = size; 
  handle2Ptr->ixEnd = 1;                    // TODO AtomicAccess if mulitple cores run more instances of such routines.
}  



/**Sub routine to register a pointer in the shared memory data.
 * @return the handle.
 */
static int32 setPtr_Handle2Ptr(void* ptr, SimStruct *S) {
  uint32 ix = handle2Ptr->ixEnd;
  if(ix >= handle2Ptr->size) {
    ssSetErrorStatus(S, "SharedMem for Handle to Pointer: no more space: Sfunc=<&zbnfOp.name>");
    return 0;
  }
  handle2Ptr->ixEnd = ix+1;    //TODO AtomicAccess if mulitple cores run more instances of such routines. 
  handle2Ptr->ptr[ix] = ptr;
  return ix;
}


 





#define MDL_START
#if defined(MDL_START)

/* Function: mdlStart =====================================================
 * Abstract:
 *    This function is called once at start of model execution. If you
 *    have states that should be initialized once, this is the place
 *    to do it.
 */
static void mdlStart(SimStruct *S)
{
  if (isDWorkNeeded(S)) {
    //
    //===============Get the address of the structure to convert handle values to pointer===============================
    //Note: If more as one instance of this FB will be created, the mdlStart is invoked for any instance.
    //      But there is only one static shMemHandle2Ptr. The first mdlStart creates it. Don't call twice!
    //       
    //
    if(!os_isReadySharedMem(&shMemHandle2Ptr)) {  //only if it is not created already:
      MemC mHandle2Ptr = os_createOrAccessSharedMem(&shMemHandle2Ptr, "Smlk-SfuncHandle2Ptr-2017-02", length_Handle2Ptr);
      handle2Ptr = PTR_OS_PtrValue(mHandle2Ptr, Handle2Ptr);
      if(!os_isReadySharedMem(&shMemHandle2Ptr) || handle2Ptr == null) {
        ssSetErrorStatus(S, "SharedMem for Handle to Pointer not possible, abort: Sfunc=<&zbnfOp.name>");
        return;
      }
      if(handle2Ptr->size == 0){ 
        init_Handle2Ptr(1000);          //First access: initialize it. TODO: Variable size.
      }
    }
    if(handle2Ptr == null || handle2Ptr->size != 1000) {
      ssSetErrorStatus(S, "SharedMem for Handle to Pointer faulty or size faulty, abort: Sfunc=<&zbnfOp.name>");
      return;
    }
    ##sub routine
    ##Sets the DWork with the handle of thiz, the address of thiz and the positions of elements in buses.
    //
    //============== mdlStart from ctor ==================================================
    //
    <:call:setBusInfo_mdlStartHandle:zbnfOp=zbnfCtor>
    //============== mdlStart from <&zbnfOp.name> ==================================================
    //
    <:call:setBusInfo_mdlStartHandle:zbnfOp=zbnfOp>

  }
}

#endif











#define MDL_INITIALIZE_CONDITIONS
#if defined(MDL_INITIALIZE_CONDITIONS)

/* Function: mdlInitializeConditions ======================================
 * Abstract:
 *    In this function, you should initialize the states for your S-function block.
 *    You can also perform any other initialization activities that your
 *    S-function may require. Note, this routine will be called at the
 *    start of simulation and if it is present in an enabled subsystem
 *    configured to reset states, it will be call when the enabled subsystem
 *    restarts execution to reset the states.
 */
static void mdlInitializeConditions(SimStruct *S)
{
  if (isDWorkNeeded(S)) {
    <:if:zbnfCtor><:call:genCtorHandle:zbnfCtor=zbnfCtor><.if>
  }
}

#endif













/* Function: mdlOutputs ===================================================
 * Abstract:
 *    In this function, you compute the outputs of your S-function
 *    block. Generally outputs are placed in the output vector(s),
 *    ssGetOutputPortSignal.
 */
static void mdlOutputs(SimStruct *S, int_T tid)
{ //TODO there is a problem yet now: Because of Hybrid timing of the blocks
  //     this routine is invoked in all step times.
  //     but only the main step time should invoke the zbnfOp, the core operation.
  //     TODO check tid, it seems to be 0 any time.
  //     Anything faulty in initialize timings?
  if (isDWorkNeeded(S)) {
    <:call:genSfH_stepFnH:zbnfOp=zbnfOp, zbnfCtor=zbnfCtor>
  }
}










    
/* Function: mdlTerminate =================================================
 * Abstract:
 *    In this function, you should perform any actions that are necessary
 *    at the termination of a simulation.
 */
static void mdlTerminate(SimStruct *S)
{
  if (isDWorkNeeded(S)) {
    <:call:freeMem_mdlTerminateHandle>
  }
}







#define MDL_RTW
#if defined(MATLAB_MEX_FILE) && defined(MDL_RTW)

/* Function: mdlRTW =======================================================
 * Abstract:
 *    This function is called when Simulink Coder is generating
 *    the model.rtw file.
 */
static void mdlRTW(SimStruct *S)
{
}

#endif


/* Function: CheckDataTypeChecksum ======================================
 * Abstract:
 *    CheckDataTypeChecksum invokes a MATLAB helper for checking the consistency
 *    between the data type definition used when this S-Function was generated
 *    and the data type used when calling the S-Function.
 */
static int_T CheckDataTypeChecksum(SimStruct *S, const char* dtypeName, uint32_T*
  chkRef)
{
  mxArray *plhs[1] = { NULL };

  mxArray *prhs[3];
  mxArray *err = NULL;
  const char *bpath = ssGetPath(S);
  int_T status = -1;
  prhs[0] = mxCreateString(bpath);
  prhs[1] = mxCreateString(dtypeName);
  prhs[2] = mxCreateDoubleMatrix(1, 4, mxREAL);
  mxGetPr(prhs[2])[0] = chkRef[0];
  mxGetPr(prhs[2])[1] = chkRef[1];
  mxGetPr(prhs[2])[2] = chkRef[2];
  mxGetPr(prhs[2])[3] = chkRef[3];
  err = mexCallMATLABWithTrap(1, plhs, 3, prhs,
    "legacycode.LCT.getOrCompareDataTypeChecksum");
  mxDestroyArray(prhs[0]);
  mxDestroyArray(prhs[1]);
  mxDestroyArray(prhs[2]);
  if (err==NULL && plhs[0]!=NULL) {
    status = mxIsEmpty(plhs[0]) ? -1 : (int_T) (mxGetScalar(plhs[0]) != 0);
    mxDestroyArray(plhs[0]);
  }

  return status;
}













/* Function: CheckDataTypes =============================================
 * Abstract:
 *    CheckDataTypes verifies data type consistency between the data type
 *    definition used when this S-Function was generated and the data type
 *    used when calling the S-Function.
 */
static void CheckDataTypes(SimStruct *S)
{
 
  //TODO check with known bus element names and their types.
  //from where is the check sum?
  /* Verify Bus/StructType 'Param_Orthi_FB', specification * /
  {
    uint32_T chk[] = { 4189326214, 1854717099, 3653914067, 1841847726 };

    int_T status;
    status = CheckDataTypeChecksum(S, "Param_Orthi_FB", &chk[0]);
    if (status==-1) {
      ssSetErrorStatus(S,
                       "Unexpected error when checking the validity of the Simulink Bus/StructType 'Param_Orthi_FB'");
    } else if (status==0) {
      ssSetErrorStatus(S,
                       "The Simulink Bus/StructType 'Param_Orthi_FB' definition has changed since the S-Function was generated");
    }
  }
  TODO */
}











/* Function: GetRTWEnvironmentMode ======================================
 * Abstract:
 *    Must be called when ssRTWGenIsCodeGen(S)==true. This function
 *    returns the code generation mode:
 *      -1 if an error occurred
 *       0 for standalone code generation target
 *       1 for simulation target (Accelerator, RTW-SFcn,...)
 */
static int_T GetRTWEnvironmentMode(SimStruct *S)
{
  int_T status;
  mxArray *plhs[1];
  mxArray *prhs[1];
  int_T err;

  /*
   * Get the name of the Simulink block diagram
   */
  prhs[0] = mxCreateString(ssGetModelName(ssGetRootSS(S)));
  plhs[0] = NULL;

  /*
   * Call "isSimulationTarget = rtwenvironmentmode(modelName)" in MATLAB
   */
  mexSetTrapFlag(1);
  err = mexCallMATLAB(1, plhs, 1, prhs, "rtwenvironmentmode");
  mexSetTrapFlag(0);
  mxDestroyArray(prhs[0]);

  /*
   * Set the error status if an error occurred
   */
  if (err) {
    if (plhs[0]) {
      mxDestroyArray(plhs[0]);
      plhs[0] = NULL;
    }

    ssSetErrorStatus(S, "Unknown error during call to 'rtwenvironmentmode'.");
    return -1;
  }

  /*
   * Get the value returned by rtwenvironmentmode(modelName)
   */
  if (plhs[0]) {
    status = (int_T) (mxGetScalar(plhs[0]) != 0);
    mxDestroyArray(plhs[0]);
    plhs[0] = NULL;
  }

  return (status);
}

/*
 * Required S-function trailer
 */
#ifdef MATLAB_MEX_FILE
# include "simulink.c"
#else
# include "cg_sfun.h"
#endif

<.>
}
##end of the sub wrapperCHandle, the text of a C-wrapper.
###################################################################################################################







#####################################################################################################################
##
## sub routines for details 
##







##
##Generate C-wrapper-code for mdlCheckParameters
##
sub mdlCheckParamsHandle(use-locals)
{ 
Num ixParam = 0;
    <:><:indent:4=>
====#define MDL_CHECK_PARAMETERS
====#if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)
====
====/* Function: mdlCheckParameters ===========================================
==== * Abstract:
==== *    mdlCheckParameters verifies new parameter settings whenever parameter
==== *    change or are re-evaluated during a simulation. When a simulation is
==== *    running, changes to S-function parameters can occur at any time during
==== *    the simulation loop.
==== */
====static void mdlCheckParameters(SimStruct *S)
===={
====<.>
  for(arg: zbnfCtor.args) {
    if(arg.name != "thiz") {
      String type = &SfuncTypes.get(arg.type.name);
      <:>
  ====  if EDIT_OK(S, <&ixParam>) {
  ====    int_T dimsArray[1] = { 1};
  ====  
  ====    /* Check the parameter attributes */
  ====    //TODO ? ssCheckSFcnParamValueAttribs(S, <&ixParam>, "<&arg.name>", <&type>, 0, dimsArray, 0);  //<&arg.type.name>
  ====  }
      <.>
      ixParam = ixParam +1; 
  } } //for if  
    <:><:indent:4=>  
====}
====
====#endif
====
====
====
====
====                                                             
====
====
====#define MDL_PROCESS_PARAMETERS
====#if defined(MDL_PROCESS_PARAMETERS) && defined(MATLAB_MEX_FILE)
====
====/* Function: mdlProcessParameters =========================================
==== * Abstract:
==== *    Update run-time parameters.
==== */
====static void mdlProcessParameters(SimStruct *S)
===={
====  /* Update Run-Time parameters */
====  ssUpdateAllTunableParamsAsRunTimeParams(S);
====}
====
====#endif
    <.>
}















##
##generates code for ssSetNumSFcnParams(...)
##
sub gen_checkParametersHandle(use-locals) {  
  if(zbnfCtor) {
    Num nrParams = zbnfCtor.args.size() -1;
    <:>
====  /* Number of expected parameters */
====  ssSetNumSFcnParams(S, <&nrParams>);
====  #if defined(MATLAB_MEX_FILE)
====
====  if (ssGetSFcnParamsCount(S) == <&nrParams>) {
====    /*
====     * If the number of expected input parameters is not equal
====     * to the number of parameters entered in the dialog box return.
====     * Simulink will generate an error indicating that there is a
====     * parameter mismatch.
====     */
====    mdlCheckParameters(S);
====    if (ssGetErrorStatus(S) != NULL) {
====      return;
====    }
====  } else {
====    /* Return if number of expected != number of actual parameters */
====    return;
====  }
====
====  #endif<.>

    Num ixParams = 0;
    for(arg: zbnfCtor.args) {
      if(arg.name != "thiz") {  ##all args except thiz are parameter of the constructor.
        <:>
========  ssSetSFcnParamTunable(S, <&ixParams>, 1);  //<&arg.name> <.>
        ixParams = ixParams +1;
    } }  //for if
  } else {
    <:>
====  ssSetNumSFcnParams(S, 0);  //no Parameters, no ctor<.>
  }
}



    
    







##
##Generates code for RunTimeParamInfo
##Only invoked if a zbnfCtor is present.
##
sub setRuntimeParamsHandle(use-locals) {  
  Num nrParams = zbnfCtor.args.size() -1;
  <:>
==  //======= Number of runtime parameters ==============================================
==  //NOTE SFunc: This is the necessary operation to support ssGetRunTimeParamInfo(...)
==  if (!ssSetNumRunTimeParams(S, <&nrParams>))
==    return;
==  <.>  
  Num ixParams = 0;
  ##while(ixParams < nrParams) {
  for(arg: zbnfCtor.args) {
    if(arg.name != "thiz") {
      String type = &SfuncTypes.get(arg.type.name);  ##get the simulink type identifier.
      <:>
======  ssRegDlgParamAsRunTimeParam(S, <&ixParams>, <&ixParams>, "<&arg.name>", <&type>);<.>
      ixParams = ixParams +1;
  } }  //for if
}



    
    
    
    
sub initDworkBusInfoHandle(use-locals)
{
  Num ixBusInfo = 0;  ##counts for all buses
  Bool NumDworkSet = 0;
  for(arg:zbnfOp.args)
  { ##translate name:
    if(not SfuncTypes.get(arg.type.name)) {  ##not a primitive type
      Obj busInfo = allBuses.get(arg.type.name);
      if(busInfo) {
        Num arraysize = 1; if(arg.arraysize) { arraysize = arg.arraysize.value; } ##is null on scalar.
        ixBusInfo = ixBusInfo + busInfo.size();
      } else {
        <+out>ERROR bus not found: <&arg.type.name><.+n>
      }
      if(arg.name == "thiz_y" || arg.name == "thiz" && zbnfCtor) {
        NumDworkSet = 1;
        <:>
========  //Dwork is needed
========  if (!ssSetNumDWork(S, 3))  //3 Dwork Pointer, 0 for Bus indices, 1 for thiz handle, 2 for thiz 
========    return;
========  /*
========   * Configure the dwork 0, 1 (thiz)
========   */
========  ssSetDWorkDataType(S, 2, SS_DOUBLE);  //void* needs at least 8 bytes. Pointer type?
========  ssSetDWorkUsageType(S, 2, SS_DWORK_USED_AS_DWORK);
========  ssSetDWorkName(S, 2, "thiz");
========  ssSetDWorkWidth(S, 2, 1);   
========  ssSetDWorkComplexSignal(S, 2, COMPLEX_NO);
========  
========  ssSetDWorkDataType(S, 1, SS_UINT32);
========  ssSetDWorkUsageType(S, 1, SS_DWORK_USED_AS_DWORK);
========  ssSetDWorkName(S, 1, "thiz_h");
========  ssSetDWorkWidth(S, 1, 1);   
========  ssSetDWorkComplexSignal(S, 1, COMPLEX_NO);
========  <.>  
  } } } //if for if
    
  if(ixBusInfo > 0){
    if(not NumDworkSet) {
      <:>
      //Dwork is needed
      if (!ssSetNumDWork(S, 1))  //1 Dwork Pointer, only 0 for Bus indices 
        return;
      <.>
    }
    <:>
====  //jzTc: Configure the dwork 2 (__dtBusInfo)
====  ssSetDWorkDataType(S, 0, SS_INT32);
====  ssSetDWorkUsageType(S, 0, SS_DWORK_USED_AS_DWORK);
====  ssSetDWorkName(S, 0, "dtBusInfo");
====  ssSetDWorkWidth(S, 0, <&ixBusInfo>);          //number of bus members.
====  ssSetDWorkComplexSignal(S, 0, COMPLEX_NO);
    <.>
  }
    
    
}    
    
    
    
    
    
    
    
    
    
    
    
    











##
##Generates the code for the mdlInitializeSizes(SimStruct *S) for all ports.
##
##This routine is important for the tlc files too.
##
sub initPortsHandle(use-locals)
{
  
  Num ixPort=0;
  for(arg:zbnfOp.args) {  ##count number of input ports (args) 
    ##debug;
    if(not arg.name.endsWith("_y") && not arg.name.endsWith("_ybus") && not(arg.name == "thiz" && zbnfCtor)) {  
      ##all arguments of the operation which does not ends with _y or _ybus or which is not thiz if a ctor is present, are inputs.
      ixPort=ixPort+1;  
    }
  }
  <:>
==  /*
==   * Set the number of input ports.
==   */
==   
==  if (!ssSetNumInputPorts(S, <&ixPort>))
==    return;
==  <.>
  ixPort = 0;  ##call outputs  
  for(arg:zbnfOp.args)
  { if(not arg.name.endsWith("_y") && not arg.name.endsWith("_ybus") && not(arg.name == "thiz" && zbnfCtor)) 
    { ##all arguments of the operation which does not ends with _y or _ybus or which is not thiz if a ctor is present, are inputs.
      <:>
======  /*
======   * Configure the input port <&ixPort>   jzcmd: initPorts()-A
======   */
======<.>
      ##translate name:
      String complexity = &SfuncComplexity.get(arg.type.name);
      String type = &SfuncTypes.get(arg.type.name);
      if(not complexity) {
        complexity = "COMPLEX_NO";
      }
      Num arraySize = 1;
      if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
      ##
      ## Bus or not bus:
      if(type) {  ##type is known, a primitive, not a pointer.
        <:>
          ssSetInputPortDataType(S, <&ixPort>, <&type>); //input port <&arg.name>
          ssSetInputPortSampleTime(S, <&ixPort>, Tstep);   //together with ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES)
          ssSetInputPortOffsetTime(S, <&ixPort>, 0);
        <.>
      } else {
        ##an unknown standard type should be a pointer type, use as handle type
        complexity = "COMPLEX_NO";
        <:>
          ssSetInputPortDataType(S, <&ixPort>, SS_UINT32);  //input port <&arg.name>, it is a handle as reference
          //Gets the value of the Tinit time from the global workspace variable Tinit.
          if(Tinit ==0){
            int error;
            mxArray* args[2];
            mxArray* out;
            args[0] = mxCreateString("base");
            args[1] = mxCreateString("Tinit");
            error = mexCallMATLAB(1, &out, 2, args, "evalin"); //eval in workspace base
            if(error !=0) {
              ssSetErrorStatus(S,"In <&zbnfOp.name>.<&arg.type.name>: The workspace should contain a variable 'Tinit' with a real value.");
              return;
            }
            Tinit = *mxGetPr(out);   //gets the double result 
          }
          ssSetInputPortSampleTime(S, <&ixPort>, Tinit);   //together with ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES)
          ssSetInputPortOffsetTime(S, <&ixPort>, 0);
        <.>
        nrSampleTimes = 2;  ##if Tinit is used, we need 2 Sample times.
      }
      <:>
        //jzcmd: initPorts()-C
        ssSetInputPortWidth(S, <&ixPort>, <&arraySize>);
        ssSetInputPortComplexSignal(S, <&ixPort>, <&complexity>);
        ssSetInputPortDirectFeedThrough(S, <&ixPort>, 1);
        ssSetInputPortAcceptExprInRTW(S, <&ixPort>, 1);
        ssSetInputPortOverWritable(S, <&ixPort>, 1);
        ssSetInputPortOptimOpts(S, <&ixPort>, SS_REUSABLE_AND_GLOBAL);
        ssSetInputPortRequiredContiguous(S, <&ixPort>, 1);
      <.>
      ixPort=ixPort+1;
  } } //for if

  <:>
    nrofInputPorts = <&ixPort>;
  <.>
  ##
  ##Output ports:
  ##
  
  ixPort=0;
  for(arg:zbnfOp.args) {  //count number of output ports (args) 
    if(arg.name.endsWith("_y") || arg.name.endsWith("_ybus") || (arg.name == "thiz" && zbnfCtor)){  ixPort=ixPort+1;  }
    if(arg.name == "thiz_y" || (arg.name == "thiz" && zbnfCtor)){  ixPort=ixPort+1;  }  ##2 outputs for thiz
    
  }
  
<:>
  /*
   * Set the number of output ports.
   */
   
  if (!ssSetNumOutputPorts(S, <&ixPort>))
    return;
  nrofOutputPorts = <&ixPort>;
<.>
  ixPort = 0;  
  for(arg:zbnfOp.args)
  { if(  arg.name.endsWith("_y")              ##all arguments with name_y are outputs.
      || arg.name.endsWith("_ybus")           ##all arguments with name_ybus are outputs.
      || (arg.name == "thiz" && zbnfCtor))    ##thiz as input and a ctor is given: also an output.
    { <:>
      /*
       * Configure the output port <&ixPort>  jzcmd: initPorts()-D
       */
      <.>
      ##translate name:
      String complexity = &SfuncComplexity.get(arg.type.name);
      String type = &SfuncTypes.get(arg.type.name);
      if(not complexity) {
        complexity = "SS_REAL";
      }
      Num arraySize = 1;
      if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
      ##
      ## Bus or not bus:
      if(type) {
        <:>
          ssSetOutputPortDataType(S, <&ixPort>, <&type>);  //output <&arg.type.name> <&arg.name>  //jzTc-initPorts-outputNonBus
          ssSetOutputPortSampleTime(S, <&ixPort>, Tstep);   //together with ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES)
          ssSetOutputPortOffsetTime(S, <&ixPort>, 0);
          ssSetOutputPortWidth(S, <&ixPort>, <&arraySize>);
          ssSetOutputPortComplexSignal(S, <&ixPort>, <&complexity>);
          ssSetOutputPortOutputExprInRTW(S, <&ixPort>, 1);
          ssSetOutputPortOptimOpts(S, <&ixPort>, SS_REUSABLE_AND_GLOBAL);
        <.>
        ixPort=ixPort+1;
      } elsif(not arg.name.endsWith("_ybus")) {
        ##a handle type
        complexity = "COMPLEX_NO";
        <:>
          ssSetOutputPortDataType(S, <&ixPort>, SS_UINT32);   //output <&arg.type.name> <&arg.name> JzTc: as handle instead reference.
          if(Tinit ==0){
            int error;
            mxArray* args[2];
            mxArray* out;
            args[0] = mxCreateString("base");
            args[1] = mxCreateString("Tinit");
            error = mexCallMATLAB(1, &out, 2, args, "evalin"); //eval in workspace base
            if(error !=0) {
              ssSetErrorStatus(S,"In <&zbnfOp.name>.<&arg.type.name>: The workspace should contain a variable 'Tinit' with a real value.");
              return;
            }
            Tinit = *mxGetPr(out);   //gets the double result 
          }
          ssSetOutputPortSampleTime(S, <&ixPort>, Tinit);   //together with ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES)
          ssSetOutputPortOffsetTime(S, <&ixPort>, 0);
          ssSetOutputPortWidth(S, <&ixPort>, <&arraySize>);
          ssSetOutputPortComplexSignal(S, <&ixPort>, COMPLEX_NO);
          ssSetOutputPortOutputExprInRTW(S, <&ixPort>, 1);
          ssSetOutputPortOptimOpts(S, <&ixPort>, SS_REUSABLE_AND_GLOBAL);
        <.>
        nrSampleTimes = 2;  ##if Tinit is used, we need 2 Sample times.
        ixPort=ixPort+1;
      }
      ##
      if(arg.name == "thiz_y" || arg.name.endsWith("_ybus") || (arg.name == "thiz" && zbnfCtor)) {
        ##thiz : output as bus too.
        <:>
          #if defined(MATLAB_MEX_FILE)
            //Bus output  jzcmd: initPorts()-E
            if (ssGetSimMode(S) != SS_SIMMODE_SIZES_CALL_ONLY) {
              DTypeId dataTypeIdReg;
              ssRegisterTypeFromNamedObject(S, "<&arg.type.name>", &dataTypeIdReg);
              if (dataTypeIdReg == INVALID_DTYPE_ID) {
                ssSetErrorStatus(S,"In <&zbnfOp.name>: Bus type unknown: <&arg.type.name>");
                return;
              }  
              ssSetOutputPortDataType(S, <&ixPort>, dataTypeIdReg); //output bus <&arg.type.name> <&arg.name>  //jzTc-initPorts-outputBus
            }
          #endif
          ssSetBusOutputObjectName(S, <&ixPort>, (void *)"<&arg.type.name>");  //jzTc: bus output: <&arg.type.name>* <&arg.name>
          ssSetBusOutputAsStruct(S, <&ixPort>, 1);  //output as non virtual bus.
          ssSetOutputPortWidth(S, <&ixPort>, <&arraySize>);
          ssSetOutputPortComplexSignal(S, <&ixPort>, COMPLEX_NO);
          ssSetOutputPortOutputExprInRTW(S, <&ixPort>, 1);
          ssSetOutputPortOptimOpts(S, <&ixPort>, SS_REUSABLE_AND_GLOBAL);
          ssSetOutputPortSampleTime(S, <&ixPort>, Tstep);   //together with ssSetNumSampleTimes(S, PORT_BASED_SAMPLE_TIMES)
          ssSetOutputPortOffsetTime(S, <&ixPort>, 0);
        <.>
        ixPort=ixPort+1;
      }
  } } //for if
  
}  







##
##Sets the DWork with the handle of thiz, the address of thiz and the positions of elements in buses.
##
sub setBusInfo_mdlStartHandle(Obj zbnfOp)  ##Note called for ctor too.
{
  Num ixBus = 0;
  Num ixPort = 0;
  Num ixBusInfo = 0;  ##counts for all buses
  for(arg:zbnfOp.args)
  { ##translate name:
    String type = &SfuncTypes.get(arg.type.name);
    ##
    ## Bus or not bus:
    ##if(not type) {  ##a bus type
    if(arg.name == "thiz_y" || zbnfOp.name >= "ctor_" && arg.name == "thiz") {
      Obj busInfo = allBuses.get(arg.type.name);
      Num arraysize = 1; if(arg.arraysize) { arraysize = arg.arraysize.value; } ##is null on scalar.
      <:>
        { //Allocates the memory for the bus data for the C-function.
          //The bus data are allocated for this instance especially. 
          //jzcmd: setBusInfo_mdlStart()-A
          int size1 = sizeof(<&arg.type.name>);
          ObjectJc* ptr = (ObjectJc*)calloc(size1+1024, <&arraysize>);
          if (ptr==NULL) {
            ssSetErrorStatus(S,"Unexpected error during the memory allocation for <&arg.type.name>");
            return;
          }
          init_ObjectJc(ptr, size1, ident_newAllocated_ObjectJc);
          void** addr_ptr = (void**) ssGetDWork(S, 2);  //there is only one DWork, for thiz or thiz_y
          if(addr_ptr !=null) {
            *addr_ptr = ptr;
          } else {
            ssSetErrorStatus(S,"DWork(2) not existent:  <&zbnfOp.name>");
          }
          int32 handle = setPtr_Handle2Ptr(ptr, S);
          uint32* addr_handle = (uint32*) ssGetDWork(S, 1);  //there is only one DWork, for thiz or thiz_y
          if(addr_handle !=null) {
            *addr_handle = handle;
          } else {
            ssSetErrorStatus(S,"DWork(1) not existent:  <&zbnfOp.name>");
          }
          //
        }
        { /*
           * Access bus/struct information
           */
          int32_T *__dtBusInfo = (int32_T *) ssGetDWork(S, 0);
        
          //Initialize position and size of the elements of the simulink internal bus data. 
          //If the struct regards the same alignmens like the internal bus data in simulink, it is possible to use 
          //the address of the bus data in simulink immediately without memcpy or assignment.
          //The struct in C should regard a 8-byte-allignment.
          //TODO: Here it should be tested whether it is correct. Error and abort if it is not correct.
          //But for boolean in the bus which are bitfields in the header an assignment should be generated.
          //This is a TODO.
          //Yet only the this bus is used. All other non-standard data types (i.e. pointer types) are replaced by the handle.
          //TODO DTypeId busId = ssGetDataTypeId(S, "<&arg.type.name>"); <.>

      Num ixElem = 0;
      for(busElement: busInfo && ixElem >=0) {
        <:>
          //TODO __dtBusInfo[<&ixBusInfo>] = ssGetBusElementOffset(S, busId, <&ixElem>); //<&busElement.name> <.>
        
        ixElem = ixElem +1;
        ixBusInfo = ixBusInfo + 1;
      }
      <:>
      }<.>
      ixBus = ixBus +1;  //for all buses.
    }
  }  //for if

    
    
}






##
##This routine is called to generate mdlInitializeConditions(SimStruct *S)
##
sub genCtorHandle(Obj zbnfCtor)
{
  Num ixParam = 0;
  for(arg:zbnfCtor.args)
  {
    String complexity = &SfuncComplexity.get(arg.type.name);
    String type = &SfuncTypes.get(arg.type.name);
    if(not complexity) {
      complexity = "COMPLEX_NO";
    }
    Num arraySize = 1;
    if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
    if(arg.name == "thiz") {
      ##reflection = <:>reflection_<&arg.type.name><.>;
      <:>
======    <&arg.type.name>** addr_thiz = (<&arg.type.name>**)ssGetDWork(S,2); 
======    <&arg.type.name>* thiz = *addr_thiz;<.>
    } elsif(arg.name == "thiz_y") {
      <:>
======    #error donot use
======    <&arg.type.name>** thiz_y = (<&arg.type.name>**)ssGetDWork(S,2);
======    <&arg.type.name>* thiz =  *thiz_y; //used for check
      <.> 
    } else {
      <:>
          //jzTc: get Parameter value
          ssParamRec * <&arg.name>_paramInfo = ssGetRunTimeParamInfo(S, <&ixParam>); 
          <&arg.type.name> * <&arg.name>_addr = (<&arg.type.name> *)<&arg.name>_paramInfo->data;  //gets the address of the input data in Simulink data area.
          <&arg.type.name> <&arg.name> = *<&arg.name>_addr;  //for single elements.
      <.>
      if(arg.name == "Tstep") {
        <:>
            //jzTc: If a Parameter "Tstep" was found, it determines the 2. Sample time.
            //ssSetSampleTime(S, 1, Tstep);
            //ssSetOffsetTime(S, 1, 0) ;
        <.>
      }
      
      ixParam=ixParam+1;
    }
  }
  
  <:>
      { //NOTE: cast to (ObjectJc*) admissible because the instance is checked whether it based on ObjectJc.
        if( -1 == checkStrict_ObjectJc((ObjectJc*)thiz, sizeof(*thiz), ident_newAllocated_ObjectJc, null, null)) {
          ssSetErrorStatus(S,"malloc faulty for <&zbnfCtor.name>");
        }
        //jzTc: Call of the constructor:
        <&zbnfCtor.name>( <:for:arg:zbnfCtor.args><&arg.name><:hasNext>, <.hasNext><.for>);
      }
  <.>
}










#####################################################################################################################
##
## sub routines to generate the C S-function wrapper code for the output routine in ... static void mdlOutputs(SimStruct *S, int_T tid)
##
sub genSfH_stepFnH(Obj zbnfOp, Obj zbnfCtor)
{
  Num ixInput = 0;
  Num ixOutput = 0;
  Num ixBus = 0;
  Num ixBusInfo = 0;
  for(arg:zbnfOp.args)
  { ##translate name:
    String complexity = &SfuncComplexity.get(arg.type.name);
    String type = &SfuncTypes.get(arg.type.name);
    if(not complexity) {
      complexity = "COMPLEX_NO";
    }
    Num arraySize = 1;
    if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
    ##
    ## Bus or not bus:
    if(type) { //a primitive
      if(not arg.name.endsWith("_y")) { ##input
        <:>
========    //jzcmd: genStepMethod()-A
========    <&arg.type.name> * <&arg.name>_addr = (<&arg.type.name> *)ssGetInputPortSignal(S, <&ixInput>);  //gets the address of the input data in Simulink data area.
========    <&arg.type.name> <&arg.name> = *<&arg.name>_addr;  //for single elements.
        <.>
        ixInput=ixInput+1;
      } 
      else {  ##output
        <:>
========    //jzcmd: genStepMethod()-B
========    <&arg.type.name> * <&arg.name> = (<&arg.type.name> *)ssGetOutputPortSignal(S, <&ixOutput>);  //gets the address of the output data in Simulink data area.
========<.>
        ixOutput=ixOutput+1;
      }
    } else {
      ##a bus type
      if(not arg.name.endsWith("_y") && not arg.name.endsWith("_ybus") && not(arg.name == "thiz" && zbnfCtor)) 
      {  ##input: all arguments with name_y are outputs, all others except thiz are inputs.
        <:>
========    uint32 <&arg.name>_Handle = *(uint32*)ssGetInputPortSignal(S, <&ixInput>);  //input-handle
========    if(<&arg.name>_Handle >= handle2Ptr->ixEnd) { //jzTc: check valid handle, note: 0 gets null-Pointer
========      ssSetErrorStatus(S, "Handle faulty, abort: Sfunc=<&zbnfOp.name>");
========      return;
========    }
========    <&arg.type.name>* <&arg.name> = (<&arg.type.name>*) handle2Ptr->ptr[<&arg.name>_Handle];  //pointer from handle
========    if(<&arg.name> == null) {
========      return;  //not initialized yet, only on startup.
========    }
========    //A handle input should based on ObjectJc in any case. To prevent errors on faulty handle values, check whether the ObjectJc is correct. 
========    //extern_C struct ClassJc_t const reflection_<&arg.type.name>;
========      
========    if( -1 == checkStrict_ObjectJc((ObjectJc*)<&arg.name>, /*sizeof(<&arg.type.name>)*/0, 0, null, null)) {
========      ssSetErrorStatus(S,"faulty ObjectJc-reference in <&zbnfOp.name>: <&arg.name>");
========      return;
========    }
========    { char const* reflType = ((ObjectJc*)<&arg.name>)->reflectionClass->name;
========      if( strcmp(reflType,"<&arg.type.name>") !=0) {
========        ssSetErrorStatus(S,"<&zbnfOp.name>.<&arg.name>: faulty reference type, expected: <&arg.type.name>");
========        return;
========    } }
========    if(((ObjectJc*)<&arg.name>)->isInitialized == 0) {
========      return;  //not all aggregations are intialized yet.
========    }
========    //<.>
        
        ixInput=ixInput+1;
      }
      else { 
        ##output:
        if(arg.name == "thiz_y" || (arg.name == "thiz" && zbnfCtor)) {
          ##thiz : output as bus too.
          ##an output with name thiz_y is the init FB. The memory is not taken from the output bus because it is stored own data.
          <:>
==========    uint32* addr_<&arg.name> = (uint32*)ssGetOutputPortSignal(S, <&ixOutput>);  //address of thiz output bus in Simulink jzTc
==========    uint32 handle = *(uint32*)ssGetDWork(S, 1 );  //get handle stored in DWork in mdlStart(...)
==========    *addr_<&arg.name> = handle;                   //and output that handle 
==========    <&arg.type.name>* <&arg.name> = *(<&arg.type.name> **)ssGetDWork(S, 2 );
          <.>
          ixOutput = ixOutput +1;
          <:>
==========    MemUnit* <&arg.name>_SmlkBus = (MemUnit*)ssGetOutputPortSignal(S, <&ixOutput>);  //address of the Bus in Simulink
          <.>
        } else {
          ##All other bus outputs are simulink thinking output buses. They will be set only, not used as storage for own values. 
          ##Therefore its input content is not used, its output is set immediately, use the pointer to the simulink bus. 
          <:>
==========    //jzcmd: genStepMethod()-D1
==========    MemUnit* <&arg.name>_SmlkBus = (MemUnit*)ssGetOutputPortSignal(S, <&ixOutput>);  //address of the Bus in Simulink
==========    //use bus immediately because it is really an output bus, only thiz is copied:
==========    <&arg.type.name>* <&arg.name> = (<&arg.type.name>*)<&arg.name>_SmlkBus;
          <.>
        }
        ixOutput=ixOutput+1;
      }
      ixBus = ixBus +1;  
    }
  }  //for if

  <:>
==    time_T time = ssGetT(S);
==    	
==    if(ssIsSampleHit(S, 0, tid)) {
==      //init
==    } else {
==      //
==      //====Invoke the core-C-routine: jzcmd: genStepMethod()-E ========================================
==      //
==      <&zbnfOp.name>(<:for:arg:zbnfOp.args><&arg.name><:hasNext>, <.hasNext><.for>);
==    }
  <.>
  
  
  for(arg:zbnfOp.args)
  { ##translate name:
    String type = &SfuncTypes.get(arg.type.name);
    Num arraySize = 1;
    if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
    ##
    ## Bus or not bus:
    if(not type) {  ##a bus type
      if(arg.name == "thiz_y" || zbnfCtor && arg.name == "thiz") { 
        ##
        ##an output with name thiz_y is the init-FB. The memory is not taken from the output bus because it is stored own data.
        ##Now the output bus is filled. Note that the output bus is not an own memory area for any instance, 
        ##the same memory area can be used to transport the output especially for more as one element of an array, which is processed one by step.
        ##
        <:>
========    //Output the bus. 
========    //TODO
========    memcpy(thiz_SmlkBus, thiz, sizeof(*thiz));
        <.>
      }
    }
  }  //for if
}







sub freeMem_mdlTerminateHandle(use-locals)
{
  Num ixBus = 0;
  Num ixPort = 0;
  Num ixBusInfo = 0;  ##counts for all buses
  for(arg:zbnfOp.args)
  { ##Check whether there is a thiz_y or thiz with ctor, then malloc for that should be freed
    if (arg.name == "thiz_y" || (arg.name == "thiz" && zbnfCtor)) {  ##a bus type
      Obj busInfo = allBuses.get(arg.type.name);
      <:>
======    { //Free the memory for the <&arg.name> data //jzcmd: freeMem_mdlTerminate()-A
======      void** addr_ptr = (void**) ssGetDWork(S, 2);
======      void* ptr = *addr_ptr;
======      if(ptr != NULL) {
======        free(ptr);
======      }
======    }<.>
      ixBus = ixBus +1;  
    }
  }  //for if
  <:>
==  //close the sharedmem handle:
==  //Note: If more as one instance of this FB was created, the mdlTerminate is invoked for any instance.
==  //      But there is only one static shMemHandle2Ptr. The first mdlTerminate removes it.
==  //       
==  if(os_isReadySharedMem(&shMemHandle2Ptr)) {
==    memset(handle2Ptr, 0, length_Handle2Ptr);  //in case of non deleted shared mem: Simulink is closed, use the handles newly.
==    os_closeSharedMem(&shMemHandle2Ptr);
==  } //else: it is cleared and closed already.
==<.>
}





