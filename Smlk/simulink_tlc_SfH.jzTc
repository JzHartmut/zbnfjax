##JZcmd script to generate a matlab .m-File to generate a some buses from Header.
##made by Hartmut Schorrig,  
##Note: new name is jzTc for Java-Zbnf-Text-Command language. Old name is JZcmd. 
##Syntax see www.vishia.org/ZBNF/sf/docu/JZcmd.html 



##
##Sub routine to generate the tlc file from the given header and operation in the header.
##Argument zbnfOp is from CHeader.zbnf parsed via ZBNF, syntax component 'methodDef::='.
##Argument zbnfCtor may be null, or the ctor before the operation in the header, syntax component 'methodDef::='.
##
subtext tlctext(Obj zbnfOp, Obj zbnfCtor, String nameHeader)
<:>
%% File : <&zbnfOp.name>_SfH.tlc
%%
%% Description: 
%%   Simulink Coder TLC Code Generation file for <&zbnfOp.name>_SfH
%%
%% Simulink version      : 8.7 (R2016a) 10-Feb-2016
%% TLC file generated on : 02-Jan-2017 16:13:04

/%
     %%%-MATLAB_Construction_Commands_Start
     This is comment in tlc
%/

%implements <&zbnfOp.name>_SfH "C"

%% Function: FcnGenerateUniqueFileName ====================================
%%
%function FcnGenerateUniqueFileName(filename, type) void
  %%
  %assign isReserved = TLC_FALSE
  %foreach idxFile = CompiledModel.DataObjectUsage.NumFiles[0]
    %assign thisFile = CompiledModel.DataObjectUsage.File[idxFile]
    %if (thisFile.Name==filename) && (thisFile.Type==type)
      %assign isReserved = TLC_TRUE
      %break
    %endif
  %endforeach
  %if (isReserved==TLC_TRUE)
    %assign filename = FcnGenerateUniqueFileName(filename + "_", type)
  %endif
  %return filename
  %%
%endfunction

%% Function: BlockTypeSetup ===============================================
%%
%function BlockTypeSetup(block, system) void
  %%
  %% The Target Language must be C
  %if ::GenCPP==1
    %<LibReportFatalError("This S-Function generated by the Legacy Code Tool must be only used with the C Target Language")>
  %endif

  %assign ver = FEVAL("ver", "simulink")
  %assign factor = 1.0
  %assign slVer = 0.0
  %foreach idx = SIZE(ver.Version)[1]
    %if ISEQUAL(ver.Version[idx], ".")
      %assign factor = factor/10.0
    %else
      %assign slVer = slVer + %<ver.Version[idx]>*factor
    %endif
  %endforeach

  %if GenerateErtSFunction==1 && slVer < 6.21
    %<LibReportFatalError("S-Functions generated by the Legacy Code Tool (that use Simulink Object) may not be used in a model for which an ERT S-Function wrapper is being generated")>
  %endif

  %if ExtMode==1 && slVer < 6.3
    %<LibReportFatalError("S-Functions generated by the Legacy Code Tool (that use Simulink BusObject) may not be used in a model uses External Mode")>
  %endif

  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function" || ::isRAccel

    %if slVer < 6.21
      %<LibReportFatalError("S-Functions generated by the Legacy Code Tool (that use Simulink BusObject) may not be used in a referenced model")>
    %endif

    %assign hFileName = FcnGenerateUniqueFileName("<&zbnfOp.name>_wrapper", "header")
    %assign hFileNameMacro = FEVAL("upper", hFileName)
    %openfile hFile = "%<hFileName>.h"
    %selectfile hFile
    #ifndef _%<hFileNameMacro>_H_
    #define _%<hFileNameMacro>_H_

    #ifdef MATLAB_MEX_FILE
    #include "tmwtypes.h"
    #else
    #include "rtwtypes.h"
    #endif

    extern int <&zbnfOp.name>_Sfunc_wrapper_allocmem(void** __TODO_NotSupportedYet);
    extern int <&zbnfOp.name>_Sfunc_wrapper_freemem(void** __TODO_NotSupportedYet);

    extern void <&zbnfOp.name>_Sfunc_wrapper_initialize_conditions(void);

    extern void <&zbnfOp.name>_Sfunc_wrapper_output( const real32_T u1, const real32_T u2, const void *u3, void *__TODO_NotSupportedYet);

    extern void <&zbnfOp.name>_Sfunc_wrapper_terminate(void);

    #endif
    %closefile hFile

    %assign cFileName = FcnGenerateUniqueFileName("<&zbnfOp.name>_Sfunc_wrapper", "source")
    %openfile cFile = "%<cFileName>.c"
    %selectfile cFile
    #include <stdlib.h>
    #include <string.h>
    #ifdef MATLAB_MEX_FILE
    #include "tmwtypes.h"
    #else
    #include "rtwtypes.h"
    #endif
    #include "<&nameHeader>"
    //__TODO_NotSupportedYet
    int <&zbnfOp.name>_Sfunc_wrapper_allocmem(void** __u3BUS, int_T __u3Width, void** __y2BUS, int_T __y2Width) {
      *__u3BUS = calloc(sizeof(Param_Orthi_FB), __u3Width);
      if (*__u3BUS==NULL) return -1;

      *__y2BUS = calloc(sizeof(Orthi_FB), __y2Width);
      if (*__y2BUS==NULL) return -1;

      return 0;
    }

    //__TODO_NotSupportedYet
    int <&zbnfOp.name>_Sfunc_wrapper_freemem(void** __u3BUS, void** __y2BUS) {
      if (*__u3BUS!=NULL) free(*__u3BUS);
      *__u3BUS = NULL;

      if (*__y2BUS!=NULL) free(*__y2BUS);
      *__y2BUS = NULL;

      return 0;
    }

    //__TODO_NotSupportedYet
    void <&zbnfOp.name>_Sfunc_wrapper_initialize_conditions(void) {


      ctor_<&zbnfOp.name>();

    }

    //__TODO_NotSupportedYet
    void <&zbnfOp.name>_Sfunc_wrapper_output( const real32_T u1, const real32_T u2, const void *u3, void *__u3BUS,  real32_T *y1,  void *y2, void *__y2BUS,  int32_T *y3) {

      /*
       * Assign the Simulink Structure u3 to Legacy Structure __u3BUS
       */
      %assign dTypeId = LibBlockInputSignalDataTypeId(2)
      %<SLibAssignSLStructToUserStruct(dTypeId, "(*(Param_Orthi_FB *)__u3BUS)", "(char *)u3", 0)>


      step_<&zbnfOp.name>( (real32_T)(u1), (real32_T)(u2), (Param_Orthi_FB *) __u3BUS, y1, (Orthi_FB *) __y2BUS, y3);

      /*
       * Assign the Legacy Structure __y2BUS to the Simulink Structure y2
       */
      %assign dTypeId = LibBlockOutputSignalDataTypeId(1)
      %<SLibAssignUserStructToSLStruct(dTypeId, "(char *)y2", "(*(Orthi_FB *)__y2BUS)", 0)>

    }

    void <&zbnfOp.name>_Sfunc_wrapper_terminate(void) {


      free_Orthi_FB();

    }

    %closefile cFile

    %<LibAddToCommonIncludes("%<hFileName>.h")>
    %<LibAddToModelSources("%<cFileName>")>

  %else

    %<LibAddToCommonIncludes("<&nameHeader>")>
    %<LibAddToCommonIncludes("stdlib.h")>
    %<LibAddToCommonIncludes("string.h")>

  %endif

    %<SLibAddToStaticSources("<&nameHeader>")>
    ##%<SLibAddToStaticSources("stdlib.h")>
    ##%<SLibAddToStaticSources("string.h")>
    ##%<LibAddToCommonIncludes("stdlib.h")>
    ##%<LibAddToCommonIncludes("string.h")>

  %%
%endfunction

%% Function: BlockInstanceSetup ===========================================
%%
%function BlockInstanceSetup(block, system) void
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function" || ::isRAccel
  %else
    %<LibBlockSetIsExpressionCompliant(block)>
  %endif
  %%
%endfunction

%% Function: Start ========================================================
%%
%function Start(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function" || ::isRAccel
    %assign u3BUS_pAddr = "&" + LibBlockPWork("", "", "", 0)
    %assign y2BUS_pAddr = "&" + LibBlockPWork("", "", "", 1)
    %assign blockPath = STRING(LibGetBlockPath(block))
    //__TODO_NotSupportedYet
    if (<&zbnfOp.name>_Sfunc_wrapper_allocmem(%<u3BUS_pAddr>, %<LibBlockInputSignalWidth(2)>, %<y2BUS_pAddr>, %<LibBlockOutputSignalWidth(1)>)!=0) %<LibSetRTModelErrorStatus("\"Memory allocation failure for %<blockPath>\"")>;

  %endif 
  %%
%endfunction

%% Function: InitializeConditions  ========================================
%%
%function InitializeConditions (block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function" || ::isRAccel
    %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
    <&zbnfOp.name>_Sfunc_wrapper_initialize_conditions();
  %else 
   %%
   %%target System:
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
   ##This variant may be used if malloc is proper. Commented in jzTc
   ##<:if:zbnfCtor><:call:genTlc_ctorFnH><:else>//<&zbnfOp.name>: no ctor necessary.<.if>
   <:if:zbnfCtor>//ctor in first step see isInit_global_<:else>//<&zbnfOp.name>: no ctor necessary.<.if>

  %endif 
  %%
%endfunction

%% Function: Outputs ======================================================
%% OutputsForTID
%function Outputs(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function" || ::isRAccel
    %assign u1_val = LibBlockInputSignal(0, "", "", 0)
    %assign u2_val = LibBlockInputSignal(1, "", "", 0)
    %assign u3_ptr = LibBlockInputSignalAddr(2, "", "", 0)
    %assign u3BUS_ptr = LibBlockPWork("", "", "", 0)
    %assign y1_ptr = LibBlockOutputSignalAddr(0, "", "", 0)
    %assign y2_ptr = LibBlockOutputSignalAddr(1, "", "", 0)
    %assign y2BUS_ptr = LibBlockPWork("", "", "", 1)
    %assign y3_ptr = LibBlockOutputSignalAddr(2, "", "", 0)
    %%
    /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
    //__TODO_NotSupportedYet
    <&zbnfOp.name>_Sfunc_wrapper_output( %<u1_val>, %<u2_val>, %<u3_ptr>, %<u3BUS_ptr>, %<y1_ptr>, %<y2_ptr>, %<y2BUS_ptr>, %<y3_ptr>);
  %else 
    %%target System:
    <:call:genTlc_stepFnH>
  %endif 
  %%
%endfunction

%% Function: Terminate ====================================================
%%
%function Terminate(block, system) Output
  %%
  %if IsModelReferenceSimTarget() || CodeFormat=="S-Function" || ::isRAccel
    %%
    /* %<Type>(%<ParamSettings.FunctionName>): %<Name> */
    <&zbnfOp.name>_Sfunc_wrapper_terminate();
    %assign u3BUS_pAddr = "&" + LibBlockPWork("", "", "", 0)
    %assign y2BUS_pAddr = "&" + LibBlockPWork("", "", "", 1)
    %assign blockPath = STRING(LibGetBlockPath(block))
    if (<&zbnfOp.name>_Sfunc_wrapper_freemem(%<u3BUS_pAddr>, %<y2BUS_pAddr>)!=0) %<LibSetRTModelErrorStatus("\"Memory free failure for %<blockPath>\"")>;

  %else 
   %%
   %%target System:
   /* %<Type> (%<ParamSettings.FunctionName>): %<Name> */
   //TODO only for malloc-variant: free_<&zbnfOp.name>();
  %endif 
  %%
%endfunction

%% [EOF]
<.>




#####################################################################################################################
##
## sub routines to generate the tlc code for the InitializeConditions routine 
## This routine is not used yet, call is commented. It is for a target system which likes malloc.
## The alternative jzTc routine is genTlc_zbnfCtorInFirstStep() 
##
sub genTlc_ctorFnH(use-locals)
{
  Num ixParam = 0;
  <:>{ //jzTc: malloc, ctor
  <.>
  for(arg:zbnfCtor.args)
  {
    String complexity = &SfuncComplexity.get(arg.type.name);
    String type = &SfuncTypes.get(arg.type.name);
    if(not complexity) {
      complexity = "COMPLEX_NO";
    }
    Num arraySize = 1;
    if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
    if(arg.name == "thiz") {
      <:>
      %assign pthiz = LibBlockDWorkAddr(thiz, "", "", 0)
      <&arg.type.name>* thiz = (<&arg.type.name>*)malloc(sizeof(<&arg.type.name>)); 
      memset(thiz, 0, sizeof(<&arg.type.name>));
      *(<&arg.type.name>**)(%<pthiz>) = thiz;    //jzTc: store allocated thiz
      <.>
    } elsif(arg.name == "thiz_y") {
      <:>
      #error donot use
      %assign pthiz = LibBlockDWorkAddr(thiz, "", "", 0)
      <&arg.type.name>* thiz = (<&arg.type.name>*)malloc(sizeof(<&arg.type.name>)); 
      memset(thiz, 0, sizeof(<&arg.type.name>));
      *%<pthiz> = thiz;
      <.> 
    } else {
      <:>
        %assign <&arg.name>_Arg = LibBlockParameter(<&arg.name>, "", "", <&ixParam>)
      <.>
      ixParam=ixParam+1;
    }
  }
  
  <:>
  //jzTc: Call of the constructor:
  <&zbnfCtor.name>( <:for:arg:zbnfCtor.args><:if:arg.name=="thiz">thiz<:else>%<<&arg.name>_Arg><.if><:hasNext>, <.hasNext><.for>);
  }
  <.>

}





#####################################################################################################################
##
## sub routines to generate the tlc code for the Output routine to invoke the ctor the first time.
## The alternative jzTc routine is genTlc_ctorFnH() for using malloc 
##
sub genTlc_zbnfCtorInFirstStep(use-locals)
{
  Num ixParam = 0;
  for(arg:zbnfCtor.args)
  {
    String complexity = &SfuncComplexity.get(arg.type.name);
    String type = &SfuncTypes.get(arg.type.name);
    if(not complexity) {
      complexity = "COMPLEX_NO";
    }
    Num arraySize = 1;
    if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
    if((arg.name == "thiz" || arg.name == "thiz_y")) {
      <+out><&zbnfCtor.name><.+n>;
    } else {
      ##All argumens of the ctor should be LibBlockParameter!
      <:>
        %assign <&arg.name>_Arg = LibBlockParameter(<&arg.name>, "", "", <&ixParam>)
      <.>
      ixParam=ixParam+1;
    }
  }
  
  <:>
          //jzTc: Call of the constructor:
          <&zbnfCtor.name>( <:for:arg:zbnfCtor.args><:if:arg.name=="thiz">thiz /*%<thiz_y>*/<:else>%<<&arg.name>_Arg><.if><:hasNext>, <.hasNext><.for>);
  <.>
}












#####################################################################################################################
##
## sub routines to generate the tlc code for the output routine in ... %function Outputs(block, system) Output
##
sub genTlc_stepFnH(use-locals)
{
  Num ixInput = 0;
  Num ixOutput = 0;
  Num ixBus = 0;
  Num ixBusInfo = 0;
  <:>{
  <.>
  for(arg:zbnfOp.args)
  { ##translate name:
    String complexity = &SfuncComplexity.get(arg.type.name);
    String type = &SfuncTypes.get(arg.type.name);
    if(not complexity) {
      complexity = "COMPLEX_NO";
    }
    Num arraySize = 1;
    if(arg.arraysize) { arraySize = arg.arraysize.value; }  //only constant values are supported yet.
    ##
    ## Bus or not bus:
    if(type) { //a primitive
      if(not arg.name.endsWith("_y")) { ##input
        <:>
          %%jzcmd: genTlc_stepFnH()-A
          %assign <&arg.name> = LibBlockInputSignal(<&ixInput>, "", "", 0)<.>
        
        ixInput=ixInput+1;
      } 
      else {  ##output
        <:>
          %%jzcmd: genTlc_stepFnH()-B
          %assign <&arg.name> = LibBlockOutputSignalAddr(<&ixOutput>, "", "", 0)<.>
          
        ixOutput=ixOutput+1;
      }
    } else {
      ##a bus type
      if(not arg.name.endsWith("_y") && not(arg.name == "thiz" && zbnfCtor)) 
      { ##input: all arguments with name_y are outputs, all others except thiz are inputs.
        <:>
          %%:jzTc:input signal as reference 
          %assign <&arg.name> = LibBlockInputSignal(<&ixInput>, "", "", 0)<.>
        if(arg.name == "thiz") { ##thiz as input port, not zbnfCtor:
          <:>
          struct <&arg.type.name>_t* thiz = (struct <&arg.type.name>_t*)(%<<&arg.name>>); //jzTc: get input thiz as handle.<.>
          ##Note: use thiz direct for the calling argument.
        }
        ixInput=ixInput+1;
      }
      else {  //output
        if(arg.name == "thiz_y" || (arg.name == "thiz" && zbnfCtor)) {
          <:>
            %%:jzTc: thiz as output, output as handle/reference and get the bus data.
            %assign <&arg.name>_handle_ = LibBlockOutputSignalAddr(<&ixOutput>, "", "", 0)
            ##%assign pthiz = LibBlockDWorkAddr(thiz, "", "", 0)
            ##struct <&arg.type.name>_t* thiz =  *(struct <&arg.type.name>_t**)( %<pthiz>);   //jzTc: get info from Dwork
            <.>
          ixOutput = ixOutput +1;
          <:>
            %assign thiz_y = LibBlockOutputSignalAddr(<&ixOutput>, "", "", 0)
            struct <&arg.type.name>_t* thiz = /*(<&arg.type.name>_t**)*/ %<thiz_y>;
            <.>
        } else {
          ##All other bus outputs are simulink thinking output buses. They will be set only, not used as storage for own values. 
          ##Therefore its input content is not used, its output is set immediately, use the pointer to the simulink bus. 
          <:>
            %%jTc: output bus, get aus bus addr.
            %assign <&arg.name> = LibBlockOutputSignalAddr(<&ixOutput>, "", "", 0)<.>
        }            
        ixOutput=ixOutput+1;      
      }
      ixBus = ixBus +1;  
    }
  }  //for if
  if(zbnfCtor){ ##if an zbnfCtor is given, invoke it in the first step using the bus output buffers.
    <:>
    //Note: The variable isInit_global_ should be defined extern and global for the whole target system 
    //      and should be set one time on first run!
    if(isInit_global_) {  
      //jzTc: invoke constructor in the first time using the bus output buffers.
      //The Code generation should set the following options in the simulink model
      //to preserve one output bus buffer for each block:
      //OptimizeBlockIOStorage  off
	    //BufferReuse		  off
	    //GlobalBufferReuse	  off
	    <:call:genTlc_zbnfCtorInFirstStep>
    }
    <.>  
  }  
  <:>
  //jzTc: call step routine.
  <&zbnfOp.name>( <.>
  ##assemble all calling arguments for the C-routine:
  for(arg:zbnfOp.args) {
    String type = &SfuncTypes.get(arg.type.name);
    if(not type) { ##a bus
      <:>(struct <&arg.type.name>_t*) <.>
      if(arg.name == "thiz") {
      <:> thiz<.>
      } else {
        <:> /* <&arg.name> */ %<<&arg.name>><.>
      }
    } else {
      <:>%<<&arg.name>><.>
    }
    <:><:hasNext>, <.hasNext><.>
  }
  <:> );  //call the C-routine<.>
  for(arg:zbnfOp.args) {
    if(arg.name == "thiz_y" || (arg.name == "thiz" && zbnfCtor)) {  ##It is an output! See S-function mdlInitializeSizes()
      <:>
        // outout thiz as handle.
        *%<<&arg.name>_handle_> = (uint32)<&arg.name>;  //Output the handle as value of thiz (pointer). <.> 
  } }
  <:>
  } //jzTc: step 
  <.>
  
}



