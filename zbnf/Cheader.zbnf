<?ZBNF-www.vishia.de version="0.7" encoding="iso-8859-1" ?>
$xmlns:topics="http://www.vishia.de/2006/Topics".
$xmlns:xhtml="http://www.w3.org/1999/xhtml".

##yyyy-mm-dd who      what
##2015-09-30 Hartmut some spaces before ; bug: syntax error if the source had contain a space before ;
##2012-06-08 Hartmut switch-statement. Some corrections while parsing normal C-files.
##2010-10-11 Hartmut for::=, using INLINE_Fwc in headerfiles whith some expressions
##2009       Hartmut some details
##2008-04-16 Hartmut implicitStructAttribute instead attribut with @implicitStruct
##                   because it is better detectable by evaluating parse result, improve calculatin time!
##2007-12-28 Hartmut
##2007-12-28 Hartmut  semantic CLASS_C instead ClassDef for CLASS_C sections to differ from class definition


##type::= instead @ident name because construct {<$?name>?::}
##methodTyp instead @name name because construct {<$?name>?::}
##classDef instead class in CLASS_C to unify the HeaderXml2Xmi for C and C++

$keywords=return|if|else|while|do|for|switch|case|default|break|goto|public|private|protected|inline|INLINE_Fwc|static|virtualstatic_cast|struct|class|union|enum|operator|extern|extern_C|C_TYPE|METHOD_C|
.

Cheader::=
[{ #pragma <*\n?pragma> }] ##especially #pragma once is admissible
[ [ #ifndef <$?HeaderEntry>
  | #if ! defined ( <$?HeaderEntry> )          ## the test to exclude of double includes is obligate!
  ]
  # define <$?HeaderEntryDef>
]
[/*@PACKAGE <*\ *?package/@name> <*|*/?>*/]
[{ <includeDef?+@> }]    ## includes at begin
[<OutsideHeaderBlock>]
[{                        ##repetition of blocks
  /*@TOPIC <topic>
| <CLASS_CPP>
| <CLASS_C>              ##/*@CLASS_C ....
| <DEFINE_C?CLASS_C>             ##/*@DEFINE_C ....
| <ARRAY>                ##/*@ARRAY ....
| <INLINE>               ##/*@INLINE ....
##| <headerBlock>
}]
[#endif]
\e.

##:NOTE: a HeaderBlock may be also inside a condition Block. A Headerblock is the first one information.
##A conditionBlock is only a auxialary wrapper on HeaderBlocks.


##===========================================================================================================
##Block of definition in header. This is the first one information to evaluate a header but also a inner element.
headerBlock::=<?>
[ /**<description?-?>*/]
[ /*<implementDescription?-?>*/]
[ <invalidBlock?+@>
| #ifndef refl <*|#endif//refl?> #endif//refl
| #ifndef __NoReflection__ <*|#endif//__NoReflection__?> #endif//__NoReflection__
| <validBlock?>
| <conditionBlock?+conditionBlock>
| <undefDefinition>
##| extern <variableDecl?+@> ;
##| [<?modifier> extern_C| extern| static] <attribute?+?>
##| <attribute?+?>
| extern_C_BLOCK_
| _END_extern_C_BLOCK
| <enumDefinition> ;
| struct\W <structDefinition?+?> ;
| union <unionDefinition?+@> ;
| OS_PtrVal_DEF ( <OS_PtrVal_DEF?structDefinition> ) ;
##|<?constDef> const <variableDecl?+@> = [<#?value>|0x<#x?value>|<#f?floatValue>];  ##:TODO: value more variants!
|<?constDef> [static<?staticConst>] const <attribute?+?>
| [METHOD_C|C_TYPE|] typedef 
  [ struct\W <structDefinition?+@> ;
	| union <unionDefinition?+@> ;
	|<?ARRAY_Jc> ARRAY_Jc(<$?@elementType> , <#?@size>) <$?@name> ;
	| <methodPtrTypedef?+@>
	| <methodTypedef?+@>
	| <?+classDefinition> <classDef> <$?@name> ;
	|<enumDefinition> ;
	| <typedef> ;
  ]
| [inline|INLINE_Fwc] <inlineMethod?+@>
| inline <operatorDef?operator> [;|<statementBlock>]
| <includeDef?+@>
| # define CONST<defineDefinition?+const_initializer>
| # define NULL<defineDefinition?+null_initializer>
| # define INLINE_Fwc <*\n?>  ##empty, only in os_types_def.h
| # define <defineDefinition?+?>
| # error [<""?compilerError> | <*\n?compilerError>]
| # pragma <*\n?pragma>
| <classDecl?+@>
| <structDecl?+@>
| <classDef?+@> ;
##| <attribute>
| <methodDef?+@>
| <methodWithBody>
| <operatorDef?operator> [;|<statementBlock>]
| <defineUse?+@>
| [<?-modifier> extern "C" | extern_C<!\\s?>| extern<!\\s?>| static<!\\s?>|] <type?-?> [<attributedefDescr?+attribute> | {<attributedef?+attribute>  ?,} ;]
| ;  ##NOTE: an empty unnecessary semicolon is acceptable in C
].



OutsideHeaderBlock::=<?outside>
{ [?/*@]                                  ##stop repetition if /*@NEWBLOCK is detected
  <headerBlock>
}
.



topic::=<?topics:topic> <$?@ident> <*\n?><*|*/?xhtml:body+>*/.


CLASS_C::= /*@CLASS_C <$?@name> <*|*/?>*/
[ /**CLASS_C_Description <CLASS_C_Description?structDefinition>*/ ] ##instead a structDefinition itself if not exist.
{ [?/*@]                                  ##stop repetition if /*@NEWBLOCK is detected
  <headerBlock>
}
[<?virtual> /*@CLASS_C_VIRTUAL <*|*/?>*/  ##it is the block of the c-like virtual methods
  { [?/*@]                                ##stop repetition if /*@ is detected, it is the next block or the end
    <headerBlock>
  }
]
.


##/*@ARRAY ObjectRefvalues_Jc @@@@@@@
##Definition of arrays of types outside the CLASS_C-block:
ARRAY::= /*@ARRAY <$?classIdent> <*|*/?>*/
{ [?/*@]
  <headerBlock>
}
.



DEFINE_C::=/*@DEFINE[_C] [<$?@name>]<*|*/?>*/
 /**<DescriptionDEFINE_C?structDefinition>*/
{ [?/*@]
  <headerBlock>
}
.

DescriptionDEFINE_C::=<$?@name> : <description>.


INLINE::=/*@INLINE [<$?@name>]<*|*/?>*/
[ /*@ <description>*/]
{ [?/*@]
  <headerBlock>
}
.

CLASS_CPP::=/*@CLASS_CPP <*|*/?>*/
{ [?/*@]
  <headerBlock>
}
.

structDefinition::= [<$?@tagname>]
[\{ [{ <structContent?> }] \} | <macro> ]    ##NOTE: a macro can substiture a structure definition inclusive {}. Better solution: using a preprecessor.
[GNU_PACKED] {[ *<?referenceStruct>] [<$?@name>[ <arraysize>]] ? , } .

?en:structDefinition.referenceStruct::="A * before the struct-name or struct-typename inside a typedef means, the struct is used as referenced type.".

unionDefinition::=[<$?@tagname>]
\{ { ##[/**<description?-?>*/]
     [ [<?variante> struct\W <structDefinition>] ;
     | <attribute?variante>
     | # define <defineDefinition>
     | <headerBlock>
     ]
   }
\} [GNU_PACKED] [<$?@name>[ <arraysize>]].


OS_PtrVal_DEF::= <$?name> , <*)?type>.

##classDefinition::=class [<$?@tagname>] \{ [{ [ <classContent?> | <structContent?> ] }] \} <$?@name>;.

enumDefinition::= [ /**<description>*/] enum [<$?@tagname>]
\{
{ ##note before or behind enumElement there may be several defines, associated to the enum.
  [{  [/**<description?-?>*/] # define <defineDefinition?+?>}]
  [[/**<description?-?>*/]<enumElement?+?>
   [{  [/**<description?-?>*/] # define <defineDefinition?+?>}]
  ]
? ,
} 
\} [<$?@name>] .


typedef::= <type> <$?name> [ \[ [ 0x<#x?nrofArrayElements> | <#?nrofArrayElements>] \]].


##it is used in structDefinition itself: struct ...{... struct Tag_t{ .... } attribute; ...}
implicitStructAttribute::=[/**<description>*/] struct\W <structDefinition?><?@implicitStruct> ;.

##it is used in structDefinition itself: struct ...{... struct Tag_t{ .... } attribute; ...}
implicitUnionAttribute::=[/**<description>*/] union\W <structDefinition?><?@implicitStruct> ;.

##it is a method head, declaration.
methodDef::= [METHOD_C|extern "C"|extern_C |extern |C_TYPE |] <type> {<$?name>? ::} ([|<methodArgumentList?>] )
[<?@modifier>volatile|const|] [;|<statementBlock>|].

methodPtrTypedef::= [METHOD_C |extern "C"|extern_C |extern |C_TYPE |] <type> ( [<$?class> :: ] * <$?name> ) ([|<methodArgumentList?>]) ;.

methodTypedef::= [METHOD_C|extern "C" |extern_C |extern |C_TYPE |] <type> [<$?class> :: ] <$?name> ( [|<methodArgumentList?>] ) ;.


##a defineArgument is a define which replaces a type name - argument specification with a simple identifier. It's used for special cases.
methodArgumentList::=
{ <conditionalArgument>
| \.\.\.<?variableArgs> [<$?>]  ##an identifier <$?> after ... of a <?variableArgs> was necessary in a UML tool, it is an empty-defined identifier for compiling, but it should be accepted here also. 
| <typedParameter> 
| void 
| <$?defineArgument>  ##any macro instead an argument, maybe necessary in special cases. 
? [?)] [,] }  ##test: Not a ")", skip a colon.
##[<conditionalArgument>]
.

##Argument in conditional block, either with , before or , after:
conditionalArgument::= # ifdef <$?conditionDef>  [,] { <typedParameter> ? , } # endif.



##block inside a header with conditional compilation via ifdef
conditionBlock::=
[ # ifdef <$?conditionDef> | # ifndef <$?conditionDefNot> | # if <*|\r|\n?!compilerCondition> ] ##in one line
[{ <headerBlock> }]
[{<?elif> #elif <*|\r|\n?!compilerCondition>
  [{ <headerBlock> }]
}]  
[<?elseConditionBlock> #else
  [{ <headerBlock> }]
]
# endif.



compilerCondition::={<?OrCondition> {<?AndCondition> [ defined ( <$?conditionDef> ) | ! defined ( <$?conditionDefNot> ) | <value?condition> ] ? && } ? \|\| }.



invalidBlock::=
# if 0
[{ <headerBlock> }]
# endif.


validBlock::=
# if 1
[{ <headerBlock> }]
# endif.


includeDef::= # include [<""?!prepFilePath>|\<<*\>?!prepFilePath><?@sysInclude>\>].


prepFilePath::=<$NoWhiteSpaces><! *?>
  [ <stringtolastinclChar/\\?@path>           ##or all chars until the last \\ or / is the path part of the file
  ]                                          ##or no path is given.
  [ <stringtolastExclChar.?@file><*?@ext>
  | <*@file>
  ]<! *?>.




##defineDefinition::=<$NoWhiteSpaces><$?@name>[( { <$?parameter/@name> ? , } )]<![ \t]*?>[<#-?intvalue>|0x<#x?hexvalue>|<""?stringvalue>|]<![ \t]*?>{<*|\n|\\|\r\n?value>? \\[\r]\n}.
## be carefull: no white spaces between defineDefinition because the white spaces have syntax deterministic functions!
## if whitespaces are overred the line may be left.
##?c? defineDefinition::= :older versions 2010-05-01 has <$?name>, this correction is from 2010-06-28
defineDefinition::=<$NoWhiteSpaces> <$?@name> [ ( {<?parameter> <![ \t]*?><$?@name> ? <![ \t]*?>, } <![ \t]*?>) ]
                   <![ \t]*?> [ <""?stringvalue>
                              | 0x<#x?hexvalue>
                              | <#-?intvalue>[\.<#?fractPart>[[E|e]<#-?exponent>]]
                              |]
                   <![ \t]*?>
                   { <*|\n|\\|\r\n?value>
                   ? \\[\r]\n
                   }.

## by value: either until a backslash followed by end of lineor until and of line,
##           repitition if backslash followed by end of line is found.

undefDefinition::= #undef<![ \t]*?><$?@name>[( { <$?parameter/@name> ? , } )].

defineUse::= <$?defineMethod> ( { <$?defineparameter> ? , } ).

classDecl::=class <$?name> ;.

structDecl::=[C_TYPE] struct\W <$?name> ;.


type::= [<?@modifier>volatile|const|] 
  [<?@forward>struct\W|class\W|union\W|] 
  [ [unsigned<?unsigend>|signed<?signed>] 
    [  ##signed and unsigned only with int types! 
      int<!\\s?> <?@name=int32>
    | short<!\\s?> int <?@name=int16>
    | short<!\\s?> <?@name=int16>
    | long long<!\\s?> <?@name=int64>
    | long int<!\\s?> <?@name=int32>
    | long<!\\s?>     <?@name=int32>
    | char<!\\s?>     <?@name=int8>
    | <?@name=int>                  ##unsigned or signed allone
    ]
  | [{ <$?environmentClass> ::}] 
    [
      int<!\\s?> <?@name=int32>
    | short int<?@name=int16> 
    | short<!\\s?> <?@name=int16> 
    | long long<!\\s?><?@name=int64> 
    | long int<!\\s?><?@name=int32> 
    | long<!\\s?><?@name=int32> 
    | char<!\\s?>     <?@name=int8>
    | long double<?@long_double>
    | <$?@name>                     ##any type name, also float, double, or a user type 
    ] 
    [ \< <type?templateType> \> ] 
  ]
  [<typeRefModifier?>]
  [<?@modifier2>volatile|const|].



typeRefModifier::=
  { * *<?@pointer2>
  | * &<?@pointerRef>
  | *<?@pointer>
  | const **<?@constPointer2>
  | const *<?@constPointer>
  | volatile *<?@volatilePointer>
  | &<?cppRef>
  }. 


inlineMethod::=<methodDef?>.

##It is a method definition.
methodWithBody::=<methodDef?+@>.


##typedParameter::= <type> [ <$?@name>[ \[ <value?sizeof> \]] [ = <value?defaultValue>] ].
typedParameter::= <type> [ <$?@name>[<arraysize>] [ = <value?defaultValue>] ].


enumElement::= [/**<description>*/] <$?@name> [ = <enumValue?> ].

classDef::=class [<$?@name>] [ : {<superclass> ? ,} ]
\{ [{ <classVisibilityBlock> | <classContent?>  }]
\}.


superclass::= <AccessRight?visibility> [<?isVirtual>virtual] { <$?name>? ::}.



##old, it doesnt considere int a,b:# attribute::= [/** <*{ *}|*/?!test_description>*/] <type> <$?name> [<arraysize>];. ## | [ = <value> ] ];.

##NOTE: <?*> means, a result from outer isn't store here, but in the deeper level.
##NOTE: attributes may be written in form: type name,name[xx],name.
##     But it doesn't consider a asterix here like int *name,*other. The first asterix is parsed associated to the type, the second cause an parse error here.
##     It is a impreciseness to the C syntax definition.  Do not use such construct, better is int* name; int* other;
##attribute::=<?*> [/**<description?-?>*/] <type?-?> {<attributedef?+attribute>  ?,} ;.
attribute::=<?> [/**<description?-?>*/] [<?-modifier> extern "C" | extern_C<!\\s?>| extern<!\\s?>| static<!\\s?>|] <type?-?> [<attributedefDescr?+attribute> | {<attributedef?+attribute>  ?,} ;].
attributedefDescr::=[<$?@name>] [ <arraysize>| : <#?bitField> |] [ = [ \{ <arrayValue> \} | <value> ] | _INIT0_ |] ; [//:<*\n?description/text>].
attributedef::=[<$?@name>] [ <arraysize>| : <#?bitField> |] [ = [ \{ <arrayValue> \} | <value> ] | _INIT0_ |].

?attributedefDescr::="Possibility to write //: as endline comment description. It is applicable if only one attribute is defined, not more as one separated with colon ".

##The short form doesn't work yet:# attribute::=<?*> [/**<description?-?>*/] <type?-?> {<?+attribute> <$?@name> [<arraysize>| = <value> |] ?,} ;.


##NOTE: \{ ... \} are defined outside to faster parse.
##NOTE: In C it is possible to write "{ 1,2,}" (comma on end), therefore the number is optional in repetition.
arrayValue::= { \{ <arrayValue> \} | <value> | <?noValue>? , }.  
?arrayValue::="constant definition of an array in C writing { value, value...}, whereby nesting is possible.".

description::= <*{ * }|*/?!test_description>.

implementDescription::= <*{ * }|*/?!test_description>.

##The test_desciption syntax is used to parse the inner structure of a description.
test_description::= <*|\e|\@?text>
[{ @return <*@\e?returnDescription/text>
 | @simulink <*@\e?simulinkTag>
 | @param <paramDescription>
 | @sizeof = <sizeofDescription>
 | @super <?superClass>
 | @bytepos = [0x<#x?bytepos/@value>|<#?bytepos/@value>]
 | @GUID = <""?GUID/@value>
## | @container = <* \s\n\r\e\.;@?containerType>
 | @container = [<$?containerType>] \< <$?containerElementType> [ * <?referencedContainerElement> ] \> [\.]
 | @headerForType = <""?headerForType>                    ##TODO is it necessary? Java2ByteCoding
 | @lastUndefsizeArray <?lastUndefsizeArray> <*@\e?lastUndefsizeArrayText>  
 | @refl:{ <*,\.\e?refl>? ,}[ \.]
 | @<auxDescription>
## | <*|\e|\@?text>    ##text till @ or till end.
 | <*\e\@?text>    ##text till @ or till end.
 }] \e.

?test_description.superClass::= "if a element is marked with @super, it is designated as the super element. 
                It should be the first in a struct, it is mostly a struct.".


?test_description.lastUndefsizeArray::= "This annotation can be written on the last element. It should be an array, 
  whereby its size is not determined. The size depends on other informations in the context.".


paramDescription::=<$?@name> <*@\e?text>.

xxparamDescription::=<$?@name> <*|\. |\.\r\n|\.\n|\e|\@?brief> [\.] [<*|\e|\@?rest/xhtml:body+> ].

auxDescription::=<$?@name> <*@\e?text>.

sizeofDescription::=<?sizeof><#?@sizeof> <*@\e?text>.
?description.sizeof ::= "The size of a element may be given as immediate numeric value. 
                        It is used for documentation (lists)." .

structContent::=<?>
[ <invalidBlock?>
| <validBlock?>
| [/**<description?-?>*/]
  typedef
  [ xx
  |<?ARRAY_Jc> ARRAY_Jc(<$?@elementType> , <#?@size>) <$?@name> ;
  | <methodPtrTypedef?+@>
  | <methodTypedef?+@>
  | struct\W <structDefinition?+@> ;
  | union <unionDefinition?+?> ;
  |<?+classDefinition> <classDef?> <$?@name> ;
  | <enumDefinition?+?> ;
  | <typedef> ;
  ]
##| [/**<description?-?>*/] union <unionDefinition?+attribute> ;
| <enumDefinition> ;
| <implicitStructAttribute>
| <implicitUnionAttribute>
| #ifndef refl <*|#endif//refl?> #endif//refl
| #ifndef __NoReflection__ <*|#endif//__NoReflection__?> #endif//__NoReflection__
| #ifndef __reflectionHidden__ <*|#endif?> #endif
| <attribute>
| [/**<description?-?>*/] # define <defineDefinition?+?>
##| [<?implicitAttribute> <structDefinition> <$?name>|xxx] ;
| <structContentInsideCondition>
| <methodPtrTypedef?+@>
].


classContent::=<?>
[ [inline] virtual <methodDef?abstractMethod> = 0 ;
| [inline] virtual <methodDef?virtualMethod> 
| [inline] virtual <operatorDef?abstractOperator> = 0 ;
| [inline] virtual <operatorDef?virtualOperator>
| static <methodDef?staticMethod>  
| static <attribute?+staticAttribute>
| #ifndef __NoReflection__ <*|#endif//__NoReflection__?> #endif//__NoReflection__
|<?friendClass> friend [class] <outerClassName> ;
| <enumDefinition> ;
|<?classForward> class <$?@name> ;
|<?structForward> struct\W <$?@name> ;
|<?implicitAttribute> <classDef> <$?name> ;
| <classDef> ;
##| <structDef?+@>
| <Destructor>
| [inline] <operatorDef?operator> [<?@modifier>volatile|const|] [ ;|<statementBlock>]
| [inline] <methodDef> 
|<?constructor> <$?@name> ( [| void |{ <typedParameter> ? ,}] ) [ : {<?initialization><$?ident>({ <value> ? ,} )? ,}][ ;| <statementBlock>]
| <attribute?+?>
##| <variableDecl>;
| <structContent?>
].


##TODO experience
outerClassName::=<$?name>[ :: <outerClassName>].
##outerClassName::=<$?-name> [::<outerClassName?+outerClass>|<?+name>].
##outerClassName::=<$?@name> :: [<outerClassName>|<?+name>].

Destructor::= [virtual] ~<$?className> ( ) [ = 0 ;<?@abstract>| ;|<statementBlock>].

operatorDef::= [<type>] operator [<?operator> ()<?parenthesis>|<assignOperator?>|<unaryOperator?>|<binaryOperator?>|<type?typeConversion>] ( [| void |{ <typedParameter> ? ,}] ).

statementBlock::=
\{ [ STACKTRC_ENTRY ( <""?STACKTRC_ENTRY> ) ; ]
[{ 
  #ifndef __reflectionHidden__ <*|#endif?> #endif
| [ # ifdef <$?conditionDef>| # ifndef <$?conditionDefNot>| # if {<?OrCondition> {<?AndCondition> [defined(<$?conditionDef>) | ! defined(<$?conditionDefNot>) ] ? && } ? \|\| } ]
  { <statement> }  ##statement in conditional compiling TODO semantic
  # endif
| <statement> 
}]
\}.

statement::=
  return [| <value?returnAssignment>] ;
| <variabledefinition>
| <simpleMethodCall> [;]   ##NOTE: If it is a call of a parametrized macro, it doesn't may have a semicolon on end.
| <assignment> ;
| <if_statement>
| <while_statement>
| <for_statement>
| <switch_statement>
| <try_statement>
| <statementBlock>
| break ;
| ;  ##NOTE: an empty unnecessary semicolon is acceptable in C
| <invalidBlock?>
| <validBlock?>
.


##variabledefinition::=<$?type> <$?attribute> [ = [<objectAccess>|<value>] ];.
variabledefinition::=<type> { [<typeRefModifier>] <$?name> [ = [<objectAccess>|<value>] ] ? , } ;.



returnAssignment::= [<objectAccess> ;|<value> ;|<assignment> ;].

assignment::= [* <variable?Refvariable>|<variable>]  <assignOperator?> [<objectAccess>| <value>|<assignment>].

value::= <assignment> |
{ [|<unaryOperator?>]
  [ <""?simpleStringLiteral>
  | <''?simpleCharLiteral>
  | & <value?referenceAddress>
  | <refCastingValue>  ##must be arranged before ( <value> ) because confusion with, example (type)value and (variable)
  | ( <value> )
  | 0x<#x?number>[<?@longModifier>L]
##  | <floatNumber>
##  | <#f?floatNumber>[<?@floatModifier>F|<?@longModifier>L|]
  | <#f?floatNumber>[<?@floatModifier>F|f|][<?@longModifier>L|l|]
  | <#-?number>[<?@longModifier>L|l|]
  | 0 <?number0>
##  | <simpleMethodCall>
  | <methodCall>
  |<?variable> [ -- <?preDecrement>| ++ <?preIncrement>|] <variable?> [ -- <?postDecrement>| ++ <?postIncrement>|]
##  | <variable>
  ##    | <!'.'?simpleChar>
  ]
?
<binaryOperator>
}

[ \? <value?value_true> : <value?value_false>]
.



assignOperator::= [<?assignOperator> = | += | \|= | &= | -= | *= | /= | \<\<= | \>\>= ].

##NOTE: It is possible in C to have more as one unary operator one before another. But that is usefull only for special situations.
##      The sequence of unary operators is checked here.  

unaryOperator::= [<?unaryOperator> - | + | ~ | ! | ! !<?unaryCastToBool> | * | & ].

##TRICKY-ZBNF: use [<?semantic> ...] to store the string value. use <?> to circumvent double storing.
binaryOperator::=<?>[<?binaryOperator> + | - | * | / | % | && | \|\| | & | \| | \>\> | \<\< | == | \>= | \<= | \> | \< | != | ^ ].
##binaryOperator::= + | - | * | / | && | \|\| | & | \| | \>\> | \<\< | == | \>= | \<= | \> | \< | != | ^ .


simpleMethodCall::= [{<$?environmentClass> ::}] <$?methodname> [( )| <actualParameter>].

conditionalActualArgument::= # ifdef <$?conditionDef>  [,] { <objectAccess>| <value?> ? , } # endif.
actualParameter::= ({ <conditionalActualArgument?> | <objectAccess> | <value?> ? [?)] [,] } ).


classVisibilityBlock::=[<?visibility> public | protected | private ] : [{ <classContent> | <structContent> }].

structContentInsideCondition::=
[/**<description>*/] 
[ #ifdef <$?conditionDef>| #ifndef <$?conditionDefNot>| #if {<?OrCondition> {<?AndCondition> [defined(<$?conditionDef>) | ! defined(<$?conditionDefNot>) ] ? && } ? \|\| } ]
  [{ <structContent> }]
[<?elseConditionBlock> #else
  [{ <structContent> }]
]
#endif.

##variableDecl::= <type> <$?name> [\[<?arrayType>\]].

AccessRight::=[<?accessRight/@value> public | private | protected |].

##arraysize can be simple, or a complex value. NOTE: Only the simpe variants are regarded in Header2Reflection. 
arraysize::= \[ [{ [ 0x<#x?@value> | <#?@value> | <$?@symbolValue> [!<binaryOperator>|\]] | <value>] ? <binaryOperator> }| <?unknown>] \] [<arraysize>].
##arraysize::=\[ [ 0x<#x?@value> | <#?@value> | <$?@symbolValue> | <*<!\\s?>\]?value>] \] [<arraysize>].
##arraysize::=\[ [ <*<!\\s?>\]?value> ] \] [<arraysize>].

?en:arraysize.unknown::="An unknown arraysize is possible on extern declarations of arrays writing 'extern type name[];' ".

## An enum value is a constant. It may be written as term "konst + konst". A konst is a number or a symbolic const.
enumValue::= { [-] 0x<#x?hexnumber>[<?@longModifier>L] | <#-?intnumber>[<?@longModifier>L] | <macro> | { <$?symbol>? ::} ? [<?operation/@value> +|-|*|\|] }.



methodCall::=[<superAccess>|<externObject>|]<simpleMethodCall>.

variable::=[ <superAccess>| <externObject>|] [{<$?environmentClass>::}] <$?simpleVariable> [\[ <value?index> \]].

superAccess::=xxx.

externObject::= { [<simpleMethodCall>|<$?association>[ \[ <value?index> \]] ] [-\>|\.] }.



if_statement::=if ( <value?condition> ) [<statementBlock>|<statement>] [ else [<statementBlock>|<statement>] ].

while_statement::=while ( <condition> ) [<statementBlock>|<statement>].

for_statement::=for ( 
  [<variabledefinition> ; | <assignment?startAssignment> ;]  
  <condition?endCondition> ; 
  [ <assignment?iteratorAssignment> | <value?iteratorExpression>]  ##NOTE: a simpleValue contains the pre- and post-increment/decrement forex: ++ix 
  ) <statement>.


	
switch_statement::=switch ( <value?switchValue> ) 
\{ [{<?case> { case <value?caseValue> : }    ##more as one case value: after another is predictable, it are more cases to the same statements.  
     [{<statement>}]                      ##but at least one statement should be written.
   }]
   [<?default> default : [{<statement>}] ] 
\}.


try_statement::=try <statementBlock> { catch ( <$?exceptionType> <$?exceptionObj> ) <statementBlock> }.


condition::=<value?>.

##objectAccess::=<nullPointer> | <newObject> .

objectAccess::=xxx.

nullPointer::=null.


refCastingValue::=
[  static_cast \< <type> \>   ##C++-safety casting
| ( <type> )                 ##C-like-casting
] <value?>
.


macro::= <$?@name> ( { <$?identArg> | <value> ? ,} ).