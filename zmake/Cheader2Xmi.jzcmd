##Zmake generate control file for XMI-generation from header or Java files.




main()
{ <+> output <.n+>
  for(target: zmake.targets){
    call *target.translator(target=target);
  }
}




##This method is used as an target. The Zmake user script file can contain 'dst := parseHeader2Xml(sources);'
sub parseCheader2Xml(Obj target)
{

  List inputsExpanded = target.allInputFilesExpanded();
  //debug test;
  String tmpxml = target.output.absdir();
  
  ##parse:
  for(input:inputsExpanded) {
    ##checkNewless: deletes the destination file if it is older than the source. call schema: checkNewless(source, destination, deleteit);
    String xml = <:><&tmpxml>/<&input.localfile()>.xml<.>;
    Obj checkNew = %org.vishia.util.FileSystem.checkNewless(input.absfile(), xml, 1);
    <+><&xml>: checkNew = <&checkNew><.n+>
    if(checkNew >= 1) {
      String exec = %org.vishia.zbnf.Zbnf2Xml.smain(<:>-i:<&input.absfile()><.>, <:>-s:<&$ZBNFJAX_HOME>/zbnf/Cheader.zbnf<.>
        , <:>-y:<&tmpxml>/<&input.localfile()>.xml<.>, <:>-a:@filename=<&input.name()><.>
        , <:>--report:<&tmpxml>/<&input.localfile()>.zbnf.rpt<.>, "--rlevel:335");
      <+>*parse: <&input.localfile()> : <&exec><.n+>
    } else {
      <+>*is parsed: <&input.localfile()><.n+>
    }
  } ##for
  

}


##This method is used as an target. The Zmake user script file can contain 'dst := genCheader2XMI(sources);'
sub genCheaderXml2XMI(Obj target)
{

  ##The ZmakeUserscript should contain a variable 'tmpxml'

  List inputsExpanded = target.allInputFilesExpanded();

  
  ##gather all inputs as argument for Xslt:
  Stringjar inputfiles = "";                                            ##variable with all input files
  List listInputs;
  for(input:inputsExpanded) {
    listInputs += <:>-i:<&input.absfile()>.xml<.>;
  }

  ##translate all input files with Java2xmiTypes.xsl to gather all types. build a temporary types-xmi.xml to use for second pass
  List xsltArgs;
  xsltArgs += <:>-t:<&$ZBNFJAX_HOME>/xsl/CheaderTypes.xsl<.>;
  xsltArgs += "-w+"; 
  xsltArgs += <:>-y:<&target.output.absdir()>/types-xmi.xml<.>;
  xsltArgs += listInputs;
  <+>invoke Xslt:<:for:arg:xsltArgs><:n>   <&arg><.for><.n+>
  String xsltresult = java org.vishia.xml.Xslt.exec(conv.stringArray(xsltArgs));
  <+><&xsltresult><.n+>
  
  ##translate all input files with Java2xmi.xsl and the types in types-xmi.xml to the output.xmi
  xsltArgs.clear();
  xsltArgs += <:>-t:<&$ZBNFJAX_HOME>/xsl/gen/Cheader2xmi.xsl<.>;
  xsltArgs += "-w+"; 
  xsltArgs += <:>-y:<&target.output.absfile()><.>;
  xsltArgs += <:>-i:<&target.output.absdir()>/types-xmi.xml<.>;
  xsltArgs += listInputs;
  <+>invoke Xslt:<:for:arg:xsltArgs><:n>   <&arg><.for><.n+>
  String xsltresult = java org.vishia.xml.Xslt.exec(conv.stringArray(xsltArgs));
  <+><&xsltresult><.n+>

  
}




##This method is used as an target. The Zmake user script file can contain 'dst := genCheader2XMI(sources);'
sub genCheader2XMI(Obj target)
{

  ##The ZmakeUserscript should contain a variable 'tmpxml'
  String tmpxml;
  if(zmake.var.tmpxml){ tmpxml = zgensub.evalString(zmake.var.tmpxml); }
  else { tmpxml = <:><&$TMP>/tmpxml<.>; }  ##System should provide a TMP, elsewhere error. 

  List inputsExpanded = target.allInputFilesExpanded();

  ##parse:
  for(input:inputsExpanded) {
    ##checkNewless: deletes the destination file if it is older than the source. call schema: checkNewless(source, destination, deleteit);
    String xml = <:><&tmpxml>/<&input.localfile()>.xml<.>;
    Obj checkNew = %org.vishia.util.FileSystem.checkNewless(input.absfile(), xml, 1);
    <+out><&xml>: checkNew = <&checkNew><.n+>
    if(checkNew >= 1) {
      String exec = %org.vishia.zbnf.Zbnf2Xml.smain(<:>-i:<&input.absfile()><.>, <:>-s:<&$ZBNFJAX_HOME>/zbnf/Cheader.zbnf<.>
        , <:>-y:<&tmpxml>/<&input.localfile()>.xml<.>, <:>-a:@filename=<&input.name()><.>
        , <:>--report:<&tmpxml>/<&input.localfile()>.zbnf.rpt<.>, "--rlevel:335");
      <+>*parse: <&input.localfile()> : <&exec><.n+>
    } else {
      <+>*is parsed: <&input.localfile()><.n+>
    }
  } ##for
  
  ##gather all inputs as argument for Xslt:
  Stringjar inputfiles = "";                                            ##variable with all input files
  List listInputs;
  for(input:inputsExpanded) {
    <+inputfiles>-i:<&tmpxml>/<&input.localfile()><.n+>;    
    listInputs += <:>-i:<&tmpxml>/<&input.localfile()>.xml<.>;
  }
  <+>
    Inputfiles:
    <&inputfiles>
  <.+>

  ##translate all input files with Java2xmiTypes.xsl to gather all types. build a temporary types-xmi.xml to use for second pass
  List xsltArgs;
  xsltArgs += <:>-t<&$ZBNFJAX_HOME>/xsl/CheaderTypes.xsl<.>;
  xsltArgs += "-w+"; 
  xsltArgs += <:>-y<&tmpxml>/types-xmi.xml<.>;
  xsltArgs += listInputs;
  String xsltresult = java org.vishia.xml.Xslt.exec(conv.stringArray(xsltArgs));
  <+out><&xsltresult><.n+>
  
  ##translate all input files with Java2xmi.xsl and the types in types-xmi.xml to the output.xmi
  xsltArgs.clear();
  xsltArgs += <:>-t<&$ZBNFJAX_HOME>/xsl/gen/Cheader2xmi.xsl<.>;
  xsltArgs += "-w+"; 
  xsltArgs += <:>-y<&target.output><.>;
  xsltArgs += <:>-i<&tmpxml>/types-xmi.xml<.>;
  xsltArgs += listInputs;
  String xsltresult = java org.vishia.xml.Xslt.exec(conv.stringArray(xsltArgs));
  <+out><&xsltresult><.n+>

  
}




