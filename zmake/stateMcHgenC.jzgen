
==JZcmd==
##Note: stm is a script variable which is filled by the stateMgen conversion control routine which calls this script.
##stm is type of org.vishia.stateMGen.StateMGen$GenStateMachine. See the maybe written report file of data structure
##given by command line arg checkdata:result/data_StatemSrc.html (data_StatemSrc.dst.html).


##!checkJZcmd = "result/check_States.genC.txt";
##!checkXml = <:><&currdir>/check_States.genC.xml<.>;

Filepath outfile = &sOutfile; ##sOutfile is defined in the java calling environment: path to the out file which is written by <+>...<.+>

String stateMethodSuffix = stm.zbnfSrc.topStateType;

Class classStateComposite = org.vishia.states.StateComposite;   ##used for instanceof check
Class classStateCompositeFlat = org.vishia.states.StateCompositeFlat;   ##used for instanceof check
Class classStateParallel = org.vishia.states.StateParallel;  ##used for instanceof check




main(){
    <+><:s>
:::://This file is generated from StateMGen.java 
::::<.+>
  for(includeline:stm.zbnfSrc.includeLines) 
  { <+>
::::#include <&includeline><.+>
  }
    <+>  
::::    
::::#include "<&outfile.name()>.h"  //include the generated header file.
::::
::::#ifdef __DEBUG_entryprintf_States_Fwc__
::::  #include <stdio.h>
::::#endif
:::://all entry-prototypes:<.+>
  for(state: stm.stateList())
  {
    <+>
::::void entry_<&state.stateId><&stateMethodSuffix>(<&stm.zbnfSrc.transFnArgs>);<.+>
  }
    <+>
::::<.+>  
  for(state: stm.stateList())
  { <+>
::::void exit_<&state.stateId><&stateMethodSuffix>(<&stm.zbnfSrc.transFnArgs>);<.+>
  }
    <+>
::::
::::<.+>
  
  call generateDoTrans();
  
  
  <+>
::
:://all const state declaration:<.+>
  for(state: stm.stateList())
  { Obj auxInfo = state.auxInfo();
    if(auxInfo && auxInfo.stateType){
      <+>
::::::extern <&auxInfo.stateType> const <&auxInfo.stateName>;<.+>
    }
  }
  <+>
::
::
::<&stm.zbnfSrc.topState.stateName> const stateConst =<.+>
  
  call generateSubStateRef(state= stm.stateTop);
  
  for(state: stm.stateList())
  { call generateStateConst(state=state);
  }

  
} ##main




sub generateDoTrans()
{

  Obj idxEntry = stm.zbnfSrc.idxEntry;
  Obj idxExit = stm.zbnfSrc.idxExit;
  Obj idxCheck = stm.zbnfSrc.idxCheck;

  
  for(state: stm.stateList())
  { Obj zsrcState = state.auxInfo(); 
  
    for(trans: state.aTransitions) 
    {
      <+>
::::::      
::::::      
:::::://Transition of <&state.stateId>
::::::static int doTrans_<&trans.transId>(<&stm.zbnfSrc.transFnArgs>)
::::::{ int trans = 0;
::::::<.+>
      for(exitState:trans.exitStates) {           
        <+>
  ::::::  #ifdef __DEBUG_entryprintf_States_Fwc__
  ::::::    printf("   exit <&exitState.stateId>;\n");
  ::::::  #endif<.+>
        if(zsrcState.hasHistory) {
          <+>
  ::::::::  //It is a composite state with a history state. Mark the state number with the inactive bit:
  ::::::::  <todo&stm.zbnfSrc.variables.stateInstance>.state<&exitState.stateId> |= 0x80000000; <.+>
        } elsif(exitState.aParallelStates) {                       
          <+>
  ::::::::  //It is a composite state without a history state. Set the state number to zero.
  ::::::::  <todo&stm.zbnfSrc.variables.stateInstance>.state<&stateComposite.stateId> = 0; <.+>
        }
        Obj exit1 = idxExit.get(exitState.stateId);
        if(exit1) {
          <+>
  ::::::::  exit_<&exitState.stateId>(<:for:argVariable:exit1.argVariables><&argVariable>, <.for>);
          <.+>
        }
      }//exitState                                           
      <+>  
::::::  <:if:trans.zsrcTrans><&trans.zsrcTrans.code><.if><.+>
      

      for(entryState:trans.entryStates) {         
        //genStateM: entry StateComposite or StateSimple. <.+>
        if(entryState.rootState) { ##check whether it is not null. It is null on a parallel state or the stateTop.                                                   
          <+>
  ::::::::  <&stm.zbnfSrc.stateInstance>.state<&entryState.rootState.stateId> = k<&entryState.stateId>_<&stateMethodSuffix>;<.+>
        }
        if(entryState.auxInfo().timeCondition) { 
          <+>
  ::::::::  <todo&stm.zbnfSrc.variables.stateInstance>.timer<&entryState.rootState.stateId> = <&entryState.auxInfo().timeCondition>;<.+>  
        } //timeCondition
        //Obj entry = stm.zbnfSrc.idxEntry.&(entryState.stateId);  //search the state in the idxEntry, search whether a entry method was defined.
        Obj entry = idxEntry.get(entryState.stateId);
        if(entry) {
          <+> 
  ::::::::  //invoke the user defined entry-method. ##with arguments
  ::::::::  entry_<&entryState.stateId>(<:for:argVariable:entry.argVariables><&argVariable><:hasNext>, <.hasNext><.for>);
          <.+>
        }
        
        
        <+>
  ::::::  #ifdef __DEBUG_entryprintf_States_Fwc__
  ::::::    printf(" entry <&entryState.stateId>;\n");
  ::::::  #endif
::::::::<.+>
      }//entryState 
      <+>    
::::::  trans |= mTransit_States_Fwc; <.+>
::::::<+>
::::::  return trans;
::::::}
::::::<.+>
    }//trans
  
  }//state
  
  

}



sub generateSubStateRef(Obj state:StateCompositeFlat)
{
  String sep = "{";
  if(state.aSubstates) { 
  for(substate: state.aSubstates) 
  {
    if(0 && substate ?instanceof classStateCompositeFlat) {
      <+>
::::::{ { 0, null } <.+>
:::::://<&substate.auxInfo().stateType> const <&substate.auxInfo().stateName> = <.+>
      
      call generateSubStateRef(state = substate);
    } else {
      <+>
::::::<&sep> &<&substate.auxInfo().stateName><.+>
    }
    sep = ",";
  }}
  <+>
::};
::
::
::<.+>


}




sub generateStateConst(Obj state:StateSimple)
{
  Obj auxInfo = state.auxInfo();
  if(auxInfo && auxInfo.stateType){
        
    <+>
::::
::::
::::<&state.auxInfo().stateType> const <&state.auxInfo().stateName>_Const =
::::{ <.+>  
    call generateSubStateRef(state=state);
  }
}

