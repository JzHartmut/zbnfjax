
==JZcmd==
##Given script variable: zsrc is a script variable which is filled by the stateMgen conversion control routine which calls this script.
##zsrc is type of org.vishia.stateMGen.StateMGen$ZbnfResultData. 
##See the maybe written report file of data structure given by command line arg checkdata:result/data_StatemSrc.html (data_StatemSrc.dst.html).
##Given script variable: sOutfile: path to the file which is written by <+>...<.+>

##!checkJZcmd = "result/check_States.genC.txt";
##!checkXml = <:><&currdir>/check_States.genC.xml<.>;

##Access to parts of the sOutfile:
Filepath outfile = &sOutfile; 

##It comes form the #define StateType_StateMgen xxx
String stateMethodSuffix = zsrc.topStateType;

##used for instanceof check:
Class classStateComposite = org.vishia.states.StateComposite;   
Class classStateCompositeFlat = org.vishia.states.StateCompositeFlat; 
Class classStateParallel = org.vishia.states.StateParallel;        
Class classStateDeepHistory = org.vishia.states.StateDeepHistory;  




main(){
    <+><:s>
:::://This file is generated from StateMGen.java 
::::#include <Fwc/fw_StateMachine.h>
::::#include "<&zsrc.headerSrc>"  //(stateMcHgen.jzgen: headerSrc)
::::<.+>
  for(includeline:zsrc.includeLines) 
  { <+>
::::#include <&includeline><.+>
  }
    <+>  
::::    
::::#include "<&outfile.name()>.h"  //include the generated header file.
::::
::::#ifdef __DEBUG_entryprintf_States_Fwc__
::::  #include <stdio.h>
::::#endif
::::
::::char const signature_State_Fwc[] = "<&zsrc.headerSrc>";
:::://all entry- and exit-prototypes: (stateMcHgenC.jzgen)<.+>

for(state: zsrc.listStates)                                  
  { <+>
::::extern <&state.stateId> const <&state.stateId>_StateConst;<.+>
  }

  for(state: zsrc.listStates) {
    call gen_exit(state=state);
    call gen_Trans(state = state);
  }
    
  for(state: zsrc.listStates) {
    if(not (state ?instanceof classStateCompositeFlat)) { //a StateCompositeFlat is never a real entered state.
      ##<+out>doTrans from: <&state.stateId><.+>
      Obj stateEncl = state; //The state which is checked.
      do {
        ##<+out> <&stateEncl.stateId><.+>
        for(trans: stateEncl.aTransitions) { call gen_DoTrans(state = state, stateEncl = stateEncl, trans = trans); }    
        stateEncl = stateEncl.enclState;
      } while(stateEncl && not (stateEncl ?instanceof classStateComposite)); //Transitions of all StateCompositeFlat.  
    }
    ##<+out><.+n>
  }
    
  
##  call exitGen();
##  call generateTrans();

  <+>
::
:://All const state declaration: (stateMcHgenC.jzgen)<.+>
  for(state: zsrc.listStates)
  { Obj auxInfo = state.auxInfo();
    <+>
::::extern <&auxInfo.stateName> const <&auxInfo.stateName>_StateConst;<.+>
  }
  
  for(state: zsrc.listStates) { call generateStatePathConst(state=state); }
  <+>
::
:://All const state definition: (stateMcHgenC.jzgen)
::
::<.+>
  for(state: zsrc.listStates) { call generateStateConst(state=state); }

  call gen_stepStates();
  call gen_stepTimer();
  
  
} ##main



##Generate the exit routine from composite states, which regards all inner states with parallel etc.
##That exit routines are necessary to exit from a enclosing state level.
##
sub XXXXXXXXXXXexitGen()
{
  <+>
::
::  
::void exitWorkGen(struct ExampleSimpleData_t* thiz, int ev)
::{
::  StateBaseGen* workState = null; //thiz->state.stateWork;
::  int ix = workState->zStatePath -1;  //last element
::  StateBaseGen const* exitState;
::  StateBaseGen const* exitStateLast;
::  while( (exitState = workState->statePath[ix]) != &Work_StateConst.Work_0x100){
::    if(exitState->parallelStates !=null){
::      for(int ixp = 0; ixp < exitState->zParallelStates; ++ixp) {
::        StateBaseGen const* exitParallelState = exitState->parallelStates[ixp];
::        if(exitParallelState != exitStateLast) { //exitStateLast is exited already.
::          exitParallelState->exit(thiz, ev);  //exit the parallel composite state
::        }
::      }
::    }
::    exitStateLast = exitState;
::  }
::
::}
::<.+>
}




sub gen_exit(Obj state: StateSimple)
{ Obj zstate = state.auxInfo();

  if(state ?instanceof classStateComposite) {
    Obj stateDefault = state.stateDefault;
    Obj zDefault = stateDefault.auxInfo();
    <+>
::::
:::://The generated exit routine calls the exit of the current state of composite and exits all states in the hierarchie till exclusive the parent composite state.
:::://It is used when the parent composite state is exited.
::::void exitGen_<&state.stateId>(<&zsrc.stateRnFormalArgs>) {
::::  //StateComposite
::::  { StateBaseGen const* stateCurr = thiz->state.state<&state.stateId>; //(stateMcHgenC.jzgen: exitComposite)
::::    if(stateCurr != null) {
::::      stateCurr->exit(<&zsrc.stateRnActArgs>);
::::    }
::::  }
::::<.+>
  } elsif( state ?instanceof classStateParallel) {
    <+>
::::
:::://The generated exit routine calls the exit of all parallel states and exits all states in the hierarchie till exclusive the parent composite state.
:::://It is used when the composite state is exited.
::::void exitGen_<&state.stateId>(<&zsrc.stateRnFormalArgs>) {<.+>
    for(pstate : state.aParallelstates ) {
      <+>
::::::  { StateBaseGen const* stateCurr = thiz->state.state<&pstate.stateId>; //(stateMcHgenC.jzgen: exitParallel)
::::::    if(stateCurr != null) {
::::::      stateCurr->exit(<&zsrc.stateRnActArgs>);
::::::    }
::::::  }
::::::<.+>
    }
  } else {
    <+>
::::
:::://The generated exit routine exits all states in the hierarchie till exclusive the parent composite state.
:::://It is used when the composite state is exited.
::::void exitGen_<&state.stateId>(<&zsrc.stateRnFormalArgs>) {<.+>
  }
  for(exitState: zstate.exitStates) {
    Obj exitRn = zsrc.idxExit.get(exitState.stateId);
    if(exitRn){
      String argListAct = <:><:for:argVariable:exitRn.argVariables><&argVariable><:hasNext>, <.hasNext><.for><.>;
      <+>
::::::  exit_<&exitRn.restName>(<&argListAct>);   //(stateMcHgen.jzgen: call exit1)<.+>
    }
    <+>
::::  #ifdef __DEBUG_entryprintf_States_Fwc__
::::    printf(" exit <&exitState.stateId>;\n");
::::  #endif<.+>
  }
  <+>
::}
::<.+>
}



##Generates code for all checkTrans routines from all states.
##Generates code for all doTrans routines which calls the correct entry and exit routines.
##
sub gen_Trans(Obj state:StateSimple)
{

  <+>
::    
::    
:://All transition execution routines: (stateMcHgenC.jzgen)
::<.+>
  
  Obj zsrcState = state.auxInfo(); 
  


  <+>
:://The transition of the state: (stateMcHgenC.jzgen: checkTransGen)
::int checkTransGen_<&state.stateId>(<&zsrc.stateRnFormalArgs>) {
::  int ret = 0 ;
::<.+>
  if(state ?instanceof classStateParallel) {
    for(pstate : state.aParallelstates ) {
      <+>
::::::  ret |= checkTransGen_<&pstate.stateId>(<&zsrc.stateRnActArgs>);
::::::<.+>
    }
    <+>
::::  if(ret & mEventConsumed_States_Fwc) {
::::    event = 0;  //don't apply the event to enclosing transitions if it was consumed intern. (stateMcHgenC.jzgen: event=0)
::::  }
::::<.+>
  }
  elsif(state ?instanceof classStateComposite) {
    Obj stateDefault = state.stateDefault;
    Obj zDefault = stateDefault.auxInfo();
    <+>
::::  { StateBaseGen const* stateCurr = thiz->state.state<&state.stateId>; //(stateMcHgenC.jzgen: genTrans)
::::    if(stateCurr == null) {
::::      //do entry.
::::      stateCurr = thiz->state.state<&state.stateId> = &<&stateDefault.stateId>_StateConst.<&zDefault.stateIdName>_<&zDefault.stateId>;
::::    }
::::    ret = stateCurr->checkTrans(<&zsrc.stateRnActArgs>);
::::    if(ret & mEventConsumed_States_Fwc) {
::::      event = 0;  //don't apply the event to enclosing transitions if it was consumed intern. (stateMcHgenC.jzgen: event=0)
::::    }
::::  }
::::<.+>
  }
  Obj trans1 = zsrc.idxCheck.get(state.stateId);
  if(trans1){ 
    <+>
::::  ret |= checkTrans_<&trans1.restName>(<&zsrc.stateRnActArgs>, &<&state.stateId>_StateConst); //(stateMcHgenC.jzgen: trans1)
::::<.+>
  }
  <+>
::  return ret;
::}
::<.+>  
}





sub gen_DoTrans(Obj state, Obj stateEncl, Obj trans)
{
  Obj idxEntry = zsrc.idxEntry;
  Obj idxExit = zsrc.idxExit;
  Obj idxCheck = zsrc.idxCheck;


  <+>
::                     
::      
:://Transition of <&state.stateId>
::static int doTrans<&state.stateId>_<&stateEncl.stateId>_<&trans.transId>(<&zsrc.transFnArgs>) //(stateMcHgenC.jzgen dotrans)
::{ int trans = 0;
::<.+>
  for(exitState:trans.exitStates) {           
    <+>
::::  #ifdef __DEBUG_entryprintf_States_Fwc__
::::    printf("   exit <&exitState.stateId>;\n");
::::  #endif<.+>
    
    ##Build the argument list for the exit, entry and trans methods:
    ##String transArgListAct = <:><:for:argVariable:exit1.argVariables>, <.for> &<&exit1.stateSrc.stateId>_StateConst<.>;
    
    ##
    if(exitState ?instanceof classStateComposite) {
      ##for a composite state the exitStateGen routine is generated regarding an given exit routine.
      <+>
::::::  //exit<&exitState.stateId>Gen(thiz, ev);  //(stateMcHgenC.jzgen exitGen)
::::::  exitGen_<&exitState.stateId>(<&zsrc.stateRnActArgs>);
::::::<.+>
    } else {
      Obj exit1 = idxExit.get(exitState.stateId);
      if(exit1) {
        String argListAct = <:><:for:argVariable:exit1.argVariables><&argVariable><:hasNext>, <.hasNext><.for><.>;
        <+>
::::::::  exit_<&exit1.restName>(<&argListAct>);   //(stateMcHgen.jzgen: call exit)<.+>
      }
    }
##        if(zsrcState.hasHistory) {
##          <+>
##  ::::::::  //It is a composite state with a history state. Mark the state number with the inactive bit:
##  ::::::::  <todo&zsrc.variables.stateInstance>.state<&exitState.stateId> |= 0x80000000; <.+>
##        } elsif(exitState.aParallelStates) {                       
##          <+>
##  ::::::::  //It is a composite state without a history state. Set the state number to zero.
##  ::::::::  <todo&zsrc.variables.stateInstance>.state<&stateComposite.stateId> = 0; <.+>
##        } 
  }//exitState                                           
  <+>  
::  <:if:trans.zsrcTrans><&trans.zsrcTrans.code><.if><.+>
  
                                                      
  for(entryState:trans.entryStates) {         
##    if(entryState ?instanceof classStateCompositeFlat) {
##      ##it is not a leave state but a composite, use the default state to enter:
##      entryState = entryState.stateDefault;
##    }
    //genStateM: entry StateComposite or StateSimple. <.+>
    if(entryState.rootState) { ##check whether it is not null. It is null on a parallel state or the stateTop.                                                   
      Obj zState = entryState.auxInfo();
      <+>
##::::  <&zsrc.stateInstance>.state<&entryState.rootState.stateId> = k<&entryState.stateId>_<&stateMethodSuffix>; //(stateMcHgenC.jzgen: set state)<.+>
::::::  <&zsrc.stateInstance>.state<&entryState.rootState.stateId> = &<&entryState.stateId>_StateConst.<&zState.stateIdName>_<&zState.stateId>; //(stateMcHgenC.jzgen: set state)<.+>
    }
    if(entryState.auxInfo().timeCondition) { 
      <+>
::::::  <todo&zsrc.variables.stateInstance>.timer<&entryState.rootState.stateId> = <&entryState.auxInfo().timeCondition>; //(stateMcHgenC.jzgen: set time )<.+>  
    } //timeCondition
    //Obj entry = zsrc.idxEntry.&(entryState.stateId);  //search the state in the idxEntry, search whether a entry method was defined.
    Obj entry = idxEntry.get(entryState.stateId);
    if(entry) {
      <+> 
::::::  entry_<&entry.restName>(<:for:argVariable:entry.argVariables><&argVariable><:hasNext>, <.hasNext><.for>);  //(stateMcHgen.jzgen: call entry) <.+>
    }
    
    
    <+>
  ::  #ifdef __DEBUG_entryprintf_States_Fwc__
  ::    printf(" entry <&entryState.stateId>;\n");
  ::  #endif
::::<.+>
  }//entryState 
  <+>    
::  trans |= mTransit_States_Fwc; <.+>   
  <+>
::  return trans;
::}                                                               
::<.+>                                                   
}



sub generateSubStateRef(Obj state:StateCompositeFlat)
{
  String sep = "";
  if(state.aSubstates) { 
  <+>
::  //The nested states, it is part of the struct definition: (stateMcHgenC.jzgen)
::,<.+>  
  for(substate: state.aSubstates) 
  {
    if(0 && substate ?instanceof classStateCompositeFlat) {
      <+>
::::::{ { 0, null }
:::::://<&substate.auxInfo().stateName> const <&substate.auxInfo().stateName> = 
::::::, <.+>
      
      call generateSubStateRef(state = substate);
      <+>
::::::};
::::::
::::::
::::::<.+>
    } elsif(substate ?instanceof classStateDeepHistory) {
      <+>
::::::<&sep> { 0 }  //deepHistory<.+>      
    } else {
      <+>
::::::<&sep> &<&substate.auxInfo().stateName>_StateConst<.+>
    }
    sep = ",";
  }}


}


sub generateStatePathConst(Obj state:StateSimple)
{
  Obj auxInfo = state.auxInfo();                                                
  String sep = "";      
    <+>
:://generateStatePathConst: (stateMcHgenC.jzgen)
:://It is the path to the nested state inside the top state, used for a history transition, used as info for documentation.
:://
::static StateBaseGen const* const statePath_<&state.auxInfo().stateName> [] = //const statePath_<&state.auxInfo().stateName>
::{<.+>
  Num nState = 0;
  for(stateParent: state.statePath) { 
    if(nState > 0) {
      Obj zState = stateParent.auxInfo();
      <+>
::::::<&sep> &<&stateParent.stateId>_StateConst.<&zState.stateIdName>_<&zState.stateId><.+>    
      sep = ",";
    }
    nState = nState + 1;
  }//for
  <+> 
::};
::
::<.+>  
}


sub generateStateConst(Obj state: StateSimple)
{
  Obj auxInfo = state.auxInfo();
  //if(auxInfo && auxInfo.stateName){
    <+>   
:::://generateStateConst: (stateMcHgenC.jzgen)
:::://It is the const description data for a state, containing the reference to the doTransition... routines.
:::://
::::<&auxInfo.stateName> const <&auxInfo.stateName>_StateConst =
::::<.+>
    call generateStateConstDef(state = state, auxInfo = auxInfo);
    <+><:s>
::::;
::::
::::<.+>
  //}
}





sub generateStateConstDef(Obj state: StateSimple, Obj auxInfo)
{ 
  String sep = ""; 
  <+><:s>
::{<.+>  
  if(state.enclState) {
    //call recursively for the parent state
    Obj enclAuxInfo = state.enclState.auxInfo();
    if(enclAuxInfo && enclAuxInfo.stateName){
      call generateStateConstDef(state = state.enclState, auxInfo = enclAuxInfo);
      sep = " , ";
##      <+>
##:::::: , <.+>      
    }
  }
  if(state.enclState && (state.enclState ?instanceof classStateParallel)) { 
    <+><:s>
::::<&sep> //(stateMcHgen.jzgen: parent state) <&state.enclState.stateId>
::::  //Root state of stateParallel
::::<.+>
  } elsif(state ?instanceof classStateParallel) {
    <+><:s>
::::<&sep> //(stateMcHgen.jzgen: parent state) <&state.enclState.stateId>
::::  //StateParallel head data: (stateMcHgenC.jzgen: StateParallel const) 
##::::  { { <&auxInfo.stateId>, checkTransGen_<&state.stateId>, &statePath_<&auxInfo.stateName>[0] } }  //stateId and reference to statePath array<.+>
::::  { signature_State_Fwc, <&auxInfo.stateId>, checkTransGen_<&state.stateId>, exitGen_<&state.stateId> }  //stateId and reference to statePath array<.+>
  } else { 
    //StateSimple or StateComposite, the data for StateBaseGen:
    <+><:s>
:::: //(stateMcHgen.jzgen: parent state) <&state.enclState.stateId>
::::<&sep> //The state const head data:
::::  { signature_State_Fwc, <&auxInfo.stateId>, checkTransGen_<&state.stateId>, exitGen_<&state.stateId><:---, &statePath_<&auxInfo.stateName>[0] ---> } //stateId and reference to statePath array<.+>
  }
  <+>
::  //The dotrans routines used in the manual written transition routines: (stateMcHgenC.jzgen)<.+>  
  for(dotransDst: auxInfo.dotransDst) {
    <+>
::::, doTrans<&state.stateId>_<&dotransDst><.+>      
  }
##  if(state ?instanceof classStateCompositeFlat) {
##    call generateSubStateRef(state=state);
##  } elsif(state ?instanceof classStateParallel) {
##    <+>
##::::  //parallel states, it is a part of struct definition: (stateMcHgenC.jzgen)<.+>  
##  }
  <+>
::}<.+>


}







sub gen_stepStates() 
{
  Obj stateDef = zsrc.stateM.stateTop.stateDefault;
  Obj zstateDef = stateDef.auxInfo();
  <+>
::int stepStates_State_<&zsrc.userDataType>(<&zsrc.stateRnFormalArgs>)     
::{ StateBaseGen const* stateTop = thiz->state.statetop;
::  if(stateTop == null) {
::    //do entry.
::    stateTop = thiz->state.statetop = &<&stateDef.stateId>_StateConst.<&zstateDef.stateIdName>_<&zstateDef.stateId>;
::  }
::  return stateTop->checkTrans(<&zsrc.stateRnActArgs>);
::}
::<.+>
}




sub gen_stepTimer() 
{
  <+>
::void stepStateTimer_State_ExampleSimpleData(struct ExampleSimpleData_t* thiz,int)
::{
::}
::<.+>
}



