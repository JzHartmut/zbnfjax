
==JZcmd==
##Note: stm is a script variable which is filled by the stateMgen conversion control routine which calls this script.
##stm is type of org.vishia.stateMGen.StateMGen$GenStateMachine. See the maybe written report file of data structure
##given by command line arg checkdata:result/data_StatemSrc.html (data_StatemSrc.dst.html).


##!checkJZcmd = "result/check_States.genC.txt";
##!checkXml = <:><&currdir>/check_States.genC.xml<.>;

Filepath outfile = &sOutfile; ##sOutfile is defined in the java calling environment: path to the out file which is written by <+>...<.+>

String stateMethodSuffix = stm.zbnfSrc.topStateType;

##used for instanceof check:
Class classStateComposite = org.vishia.states.StateComposite;   
Class classStateCompositeFlat = org.vishia.states.StateCompositeFlat; 
Class classStateParallel = org.vishia.states.StateParallel;        
Class classStateDeepHistory = org.vishia.states.StateDeepHistory;  




main(){
    <+><:s>
:::://This file is generated from StateMGen.java 
::::#include <Fwc/fw_StateMachine.h>
::::<.+>
  for(includeline:stm.zbnfSrc.includeLines) 
  { <+>
::::#include <&includeline><.+>
  }
    <+>  
::::    
::::#include "<&outfile.name()>.h"  //include the generated header file.
::::
::::#ifdef __DEBUG_entryprintf_States_Fwc__
::::  #include <stdio.h>
::::#endif
:::://all entry- and exit-prototypes: (stateMcHgenC.jzgen)<.+>
  for(state: stm.stateList())                                  
  {
    <+>
::::void entry_<&state.stateId><&stateMethodSuffix>(<&stm.zbnfSrc.transFnArgs>);
::::void exit_<&state.stateId><&stateMethodSuffix>(<&stm.zbnfSrc.transFnArgs>);<.+>
  }
  call generateDoTrans();
  <+>
::
:://All const state declaration: (stateMcHgenC.jzgen)<.+>
  for(state: stm.stateList())
  { Obj auxInfo = state.auxInfo();
    if(auxInfo && auxInfo.stateType){
      <+>
::::::extern <&auxInfo.stateType> const <&auxInfo.stateName>_StateConst;<.+>
    }
  }
  <+>
::
:://Definition of the top state: (stateMcHgenC.jzgen)
:://
::<&stm.zbnfSrc.topState.stateName> const stateConst =
::{<.+>
  
  call generateSubStateRef(state= stm.stateTop);
  <+>
::};
::
::
::<.+>
  
  for(state: stm.stateList()) { call generateStatePathConst(state=state); }
  <+>
::
:://All const state definition: (stateMcHgenC.jzgen)
::
::<.+>
  for(state: stm.stateList()) { call generateStateConst(state=state); }
  call gen_stepStates();
  call gen_stepTimer();
  
  
} ##main




sub generateDoTrans()
{

  Obj idxEntry = stm.zbnfSrc.idxEntry;
  Obj idxExit = stm.zbnfSrc.idxExit;
  Obj idxCheck = stm.zbnfSrc.idxCheck;

  <+>
::    
::    
:://All transition execution routines: (stateMcHgenC.jzgen)
::<.+>
  
  for(state: stm.stateList())
  { Obj zsrcState = state.auxInfo(); 
  
    for(trans: state.aTransitions) 
    {
      <+>
::::::      
::::::      
:::::://Transition of <&state.stateId>
::::::static int doTrans_<&trans.transId>(<&stm.zbnfSrc.transFnArgs>)
::::::{ int trans = 0;
::::::<.+>
      for(exitState:trans.exitStates) {           
        <+>
  ::::::  #ifdef __DEBUG_entryprintf_States_Fwc__
  ::::::    printf("   exit <&exitState.stateId>;\n");
  ::::::  #endif<.+>
        if(zsrcState.hasHistory) {
          <+>
  ::::::::  //It is a composite state with a history state. Mark the state number with the inactive bit:
  ::::::::  <todo&stm.zbnfSrc.variables.stateInstance>.state<&exitState.stateId> |= 0x80000000; <.+>
        } elsif(exitState.aParallelStates) {                       
          <+>
  ::::::::  //It is a composite state without a history state. Set the state number to zero.
  ::::::::  <todo&stm.zbnfSrc.variables.stateInstance>.state<&stateComposite.stateId> = 0; <.+>
        }
        Obj exit1 = idxExit.get(exitState.stateId);
        if(exit1) {
          <+>
  ::::::::  exit_<&exitState.stateId>(<:for:argVariable:exit1.argVariables><&argVariable>, <.for>);
          <.+>
        }
      }//exitState                                           
      <+>  
::::::  <:if:trans.zsrcTrans><&trans.zsrcTrans.code><.if><.+>
      

      for(entryState:trans.entryStates) {         
        //genStateM: entry StateComposite or StateSimple. <.+>
        if(entryState.rootState) { ##check whether it is not null. It is null on a parallel state or the stateTop.                                                   
          <+>
  ::::::::  <&stm.zbnfSrc.stateInstance>.state<&entryState.rootState.stateId> = k<&entryState.stateId>_<&stateMethodSuffix>;<.+>
        }
        if(entryState.auxInfo().timeCondition) { 
          <+>
  ::::::::  <todo&stm.zbnfSrc.variables.stateInstance>.timer<&entryState.rootState.stateId> = <&entryState.auxInfo().timeCondition>;<.+>  
        } //timeCondition
        //Obj entry = stm.zbnfSrc.idxEntry.&(entryState.stateId);  //search the state in the idxEntry, search whether a entry method was defined.
        Obj entry = idxEntry.get(entryState.stateId);
        if(entry) {
          <+> 
  ::::::::  //invoke the user defined entry-method. ##with arguments
  ::::::::  entry_<&entryState.stateId>(<:for:argVariable:entry.argVariables><&argVariable><:hasNext>, <.hasNext><.for>);
          <.+>
        }
        
        
        <+>
  ::::::  #ifdef __DEBUG_entryprintf_States_Fwc__
  ::::::    printf(" entry <&entryState.stateId>;\n");
  ::::::  #endif
::::::::<.+>
      }//entryState 
      <+>    
::::::  trans |= mTransit_States_Fwc; <.+>
::::::<+>
::::::  return trans;
::::::}                                                               
::::::<.+>
    }//trans
  
    <+>
:::://Transition check routine which regards all environment states too: (stateMcHgenC.jzgen)
:::://
::::int 
::::<.>
    
    
  }//state
  
  

}



sub generateSubStateRef(Obj state:StateCompositeFlat)
{
  String sep = "";
  if(state.aSubstates) { 
  <+>
::  //The nested states, it is part of the struct definition: (stateMcHgenC.jzgen)
::,<.+>  
  for(substate: state.aSubstates) 
  {
    if(0 && substate ?instanceof classStateCompositeFlat) {
      <+>
::::::{ { 0, null }
:::::://<&substate.auxInfo().stateType> const <&substate.auxInfo().stateName> = 
::::::, <.+>
      
      call generateSubStateRef(state = substate);
      <+>
::::::};
::::::
::::::
::::::<.+>
    } elsif(substate ?instanceof classStateDeepHistory) {
      <+>
::::::<&sep> { 0 }  //deepHistory<.+>      
    } else {
      <+>
::::::<&sep> &<&substate.auxInfo().stateName>_StateConst<.+>
    }
    sep = ",";
  }}


}


sub generateStatePathConst(Obj state:StateSimple)
{
  Obj auxInfo = state.auxInfo();
  if(auxInfo && auxInfo.stateType){
        
    <+>
:::://generateStatePathConst: (stateMcHgenC.jzgen)
:::://It is the path to the nested state inside the top state, used for a history transition, used as info for documentation.
:::://
::::static State_Fwc const* const statePath_<&state.auxInfo().stateType> [] = //const statePath_<&state.auxInfo().stateName>
::::{ 
::::  0
::::};
::::
::::<.+>  
  }
}


sub generateStateConst(Obj state:StateSimple)
{
  Obj auxInfo = state.auxInfo();
  if(auxInfo && auxInfo.stateType){
    <+>   
:::://generateStateConst: (stateMcHgenC.jzgen)
:::://It is the const description data for a state, containing the reference to the doTransition... routines.
:::://
::::<&auxInfo.stateType> const <&auxInfo.stateName>_StateConst =<.+>
    if(state ?instanceof classStateParallel) {
      <+>
::::::{ //StateParallel head data: (stateMcHgenC.jzgen) 
::::::  { { <&auxInfo.stateId>, &statePath_<&auxInfo.stateType>[0] } }  //stateId and reference to statePath array<.+>
    } else { //StateSimple or StateComposite
::::::<+>
::::::{ //The state const head data:
::::::  { <&auxInfo.stateId>, &statePath_<&auxInfo.stateType>[0] } //stateId and reference to statePath array<.+>
    }
    <+>
::::  //The dotrans routines used in the manual written transition routines: (stateMcHgenC.jzgen)<.+>  
    for(dotransDst: auxInfo.dotransDst) {
      <+>
::::::, doTrans_<&dotransDst><.+>      
    }
    if(state ?instanceof classStateCompositeFlat) {
      call generateSubStateRef(state=state);
    } elsif(state ?instanceof classStateParallel) {
      <+>
::::::  //parallel states, it is a part of struct definition: (stateMcHgenC.jzgen)<.+>  
    }
    <+>
::::};
::::
::::<.+>
  }
}


sub gen_stepStates() 
{
  <+>
::int stepStates_State_ExampleSimpleData(struct ExampleSimpleData_t* thiz,int){ return 0; }
::<.+>
}




sub gen_stepTimer() 
{
  <+>
::void stepStateTimer_State_ExampleSimpleData(struct ExampleSimpleData_t* thiz,int)
::{
::}
::<.+>
}



