
==JZcmd==

##!checkJZcmd = "result/check_States.genC.txt";
!checkXml = <:><&currdir>/check_States.genC.xml<.>;

subtext conditionaction(Obj trans)
<:>
  <:for:exitState:trans.exitStates>
      exit_<&exitState.src.stateName><&stm.variables.StateMethodSuffix>(thiz);
  <.for>
      <&trans.code>
   
    
  <:for:entryState:trans.dstStateTree.entrySubStates>
      entry_<&entryState.name><&stm.variables.StateMethodSuffix>(thiz);
      <:for:entryState2:entryState.entrySubStates>
        entry_<&entryState2.name><&stm.variables.StateMethodSuffix>(thiz); 
        <:for:entryState3:entryState2.entrySubStates>
        entry_<&entryState3.name><&stm.variables.StateMethodSuffix>(thiz);
          <:for:entryState4:entryState3.entrySubStates>
          entry_<&entryState4.name><&stm.variables.StateMethodSuffix>(thiz); 
          <.for>
        <.for>
      <.for>
  <.for>

<.>




sub setSubStateNull(Obj state) 
{ ##if(state.src.stateName == "RemainOn"){ debug test; }
  if(state.subStates && (state.hasHistory || state.parallelParentState)){
    <:>
        thiz->state.state<&state.src.stateName> = kNull_<&state.src.stateName>_<&stm.variables.StateSubStruct>; <.>
    for(substate:state.subStates) {
      call setSubStateNull (state = substate);
    }
  }
}





sub stateMethodArguments()
{ 
  for(arg:stm.statefnargs) { <:><&arg><:hasNext>, <.hasNext><.>; }
}



main(){


<+>
  
  /*This file is generated from StateMGen.java */

  <:for:includeline:stm.includeLines>
    #include <&includeline>
  <.for:includeline>  
  #include "<&stm.variables.StateFile>.h"
  //
  
  
  /**All function prototypes: */
  <:for:state:stm.states>
  INLINE_Fwc void entry_<&state.src.stateName><&stm.variables.StateMethodSuffix>(<&stm.variables.StateClass>* thiz); 
  INLINE_Fwc void exit_<&state.src.stateName><&stm.variables.StateMethodSuffix>(<&stm.variables.StateClass>* thiz); 
  
  <.for:state>
  
  <:for:state:stm.states><:if:state.parallelParent>
  /*Parallel state machine: <&state.src.stateName> */
  
  <:else>
  /**State <&state.src.stateName> *******************************************************************************
   * <&state.shortdescription><&state.description>
   */
  
    <&state.constDef.code> 
   
  
  
  <:if:state.entry.description>/**<&state.entry.description>
   */
  <.if><: >
  INLINE_Fwc void entry_<&state.src.stateName><&stm.variables.StateMethodSuffix>(<:subtext:stateMethodArguments>) {<: >

    ##<:if:state.src.stateName=="Active1"><:debug><.if>
    <: >
    <:if:state.parallelParentState>  ##<&state.parallelParentState><: >
      //parallelState
      ##if a parallelParentState exists this is a parallel State. don't set its ident inside the parent then.
    <:else>
      thiz->state.<&state.stateVariableName> = k<&state.src.stateName>_<&stm.variables.StateSubStruct>;
    <.if><: >
    <: >##recursive for all substates.
    <:subtext:"setSubStateNull":state=state> <: >
    
    <:for:pstate:state.parallelStates>  <: >
      <: >##recursive for all substates of parallel states. Note: The parallel state has substates.
      <:subtext:"setSubStateNull":state=pstate><: >
    <.for>
    //entry code:
    <&state.entry.code>
    //timer:
    <:for:trans:state.trans><:if:trans.time>
      thiz->timer<&state.parallelParentState> = <&trans.time>; <: >
    <.if><.for>  
  } //.entry
  
  
  
  
  
  INLINE_Fwc void exit_<&state.src.stateName><&stm.variables.StateMethodSuffix>(<&stm.variables.StateClass>* thiz){ 
    <&state.exit.code>
  } //.exit
  
  
  

  
    
  INLINE_Fwc void trans_<&state.src.stateName><&stm.variables.StateMethodSuffix>(<&stm.variables.StateClass>* thiz){ 
    <:for:trans:state.trans> <: >
    //check all conditions for a state trans:
    if(<: >
      <:if:trans.cond><&trans.cond><: >
      <:elsif:trans.time>thiz->timer<&state.parallelParentState> <:<> 0<: >
      <:elsif:trans.joinStates>
        <:for:joinState:trans.joinStates> <: >
          thiz->state.<&joinState.stateVariableName> == k<&joinState.src.stateName>_<&stm.variables.StateSubStruct> 
        <.for:joinState><: >
      <:else>/*??*/ false<.if><: >
      ) {
      <:subtext:"conditionaction": trans=trans>
      <: >
      <:for:subtrans:trans.subCondition><: >
        <:if:subtrans.cond != "else">if(<&subtrans.cond>)<.if> {
          <:subtext:"conditionaction": trans=subtrans>
        }<:hasNext> else <.hasNext>
      <.for:subtrans>  
    }
    else 
    ##<:hasNext> else <.hasNext> <&- next condition in for>
    <.for>
    { // action in state
      <&state.instate.code>
      //<&-state.test>
    }  
  }//.trans
  
  <.if><.for>
<.+>
  
  
  ##main routine with switch-case:  
<+>
  void stepStates_<&stm.variables.StateSubStruct>( <:subtext:stateMethodArguments> ) {
    switch(thiz->state.state) { <.+>
    for(state:stm.topStates){
<+>
      case k<&state.src.stateName>_<&stm.variables.StateSubStruct> : <.+>
        if(state.hasHistory) {
<+>
          switch(thiz->state.state<&state.src.stateName> {
          } <.+>
        }
      <+>  trans_<&state.src.stateName><&stm.variables.StateMethodSuffix>(thiz); break;<.+>
    }
<+>
      default: error();
    } //switch  
  }
<.+>
  
  
  
  
} ##main



sub switchcaseState(Obj state) 
{
                                                            <+>
                                                                switch(thiz->state.state<&state.StateName>) { <.+>
    for(substate:stat.subStates){
                                                            <+>
                                                                  case k<&substate.src.stateName>_<&stm.variables.StateSubStruct> : <.+>
        if(state.hasHistory) {
          call switchcaseState(state = substate);
        }                                                   <+>
                                                                    trans_<&state.src.stateName><&stm.variables.StateMethodSuffix>(thiz); 
                                                                    break;
                                                                  default: error();
                                                                } //switch
                                                                trans_<&state.src.stateName><&stm.variables.StateMethodSuffix>(thiz); break;<.+>
    }


}


