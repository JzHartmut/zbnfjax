
==JZcmd==

##!checkJZcmd = "result/check_States.genC.txt";
!checkXml = <:><&currdir>/check_States.genC.xml<.>;

Filepath outfile = &sOutfile; ##sOutfile is defined in the java calling environment: path to the out file which is written by <+>...<.+>

String stateMethodSuffix = stm.zsrcFile.variables.StateMethodSuffix;

Class classStateComposite = org.vishia.states.StateComposite;   ##used for instanceof check
Class classStateParallel = org.vishia.states.StateAddParallel;  ##used for instanceof check


subtext conditionaction(Obj trans)
<:>
  <:for:exitState:trans.exitStates>
      exit_<&exitState.src.stateName><&stateMethodSuffix>(thiz);
  <.for>
      <&trans.code>
   
    
  <:for:entryState:trans.dstStateTree.entrySubStates>
      entry_<&entryState.name><&stateMethodSuffix>(thiz);
      <:for:entryState2:entryState.entrySubStates>
        entry_<&entryState2.name><&stateMethodSuffix>(thiz); 
        <:for:entryState3:entryState2.entrySubStates>
        entry_<&entryState3.name><&stateMethodSuffix>(thiz);
          <:for:entryState4:entryState3.entrySubStates>
          entry_<&entryState4.name><&stateMethodSuffix>(thiz); 
          <.for>
        <.for>
      <.for>
  <.for>

<.>




sub setSubStateNull(Obj state) 
{ ##if(state.src.stateName == "RemainOn"){ debug test; }
  if(state.subStates && (state.hasHistory || state.parallelParentState)){
    <:>
        thiz->state.state<&state.src.stateName> = kNull_<&state.src.stateName>_<&stm.zsrcFile.variables.StateSubStruct>; <.>
    for(substate:state.subStates) {
      call setSubStateNull (state = substate);
    }
  }
}





sub stateMethodArguments()
{ 
  for(arg:stm.zsrcFile.statefnargs) { <:><&arg><:hasNext>, <.hasNext><.>; }
}



main(){


<+><: >
   //first line
::/*This file is generated from StateMGen.java */
<.+>
  for(includeline:stm.zsrcFile.includeLines) 
  { <+>
::::::#include <&includeline><.+>
  }
  <+>  
::::#include "<&outfile.name()>.h"
::::
:::://all entry-prototypes:<.+>
  for(state: stm.listStates)
  {
    <+>
::::::void entry_<&state.stateId><&stateMethodSuffix>(<&stm.zsrcFile.variables.StateClass>* thiz);<.+>
  }
  <+>
::::<.+>  
  for(state: stm.listStates)
  {
    <+>
::::::void exit_<&state.stateId><&stateMethodSuffix>(<&stm.zsrcFile.variables.StateClass>* thiz);<.+>
  }
  <+>
::::
::::<.+>
  for(state: stm.listStates)
  {
    if(state ?instanceof classStateParallel) {

    <+>
::::::static void entry_<&state.stateId><&stateMethodSuffix>(<&stm.zsrcFile.variables.StateClass>* thiz)
::::::{
::::::}
::::::
::::::INLINE_Fwc void exit_<&state.stateId><&stateMethodSuffix>(<&stm.zsrcFile.variables.StateClass>* thiz)
::::::{
::::::}
::::::<.+>

    } else {  //normal, non parallel, composite or simple:

    <+>
::::::static void entry_<&state.stateId><&stateMethodSuffix>(<&stm.zsrcFile.variables.StateClass>* thiz)
::::::{
::::::  <&stm.zsrcFile.variables.StateInstance>.state<&state.auxInfo().rootState.stateId> = k<&state.stateId>_<&stm.zsrcFile.variables.StateSubStruct>;<.+>
    if(state.auxInfo().timeCondition) { <+>
::::::  <&stm.zsrcFile.variables.StateInstance>.timer<&state.auxInfo().rootState.stateId> = <&state.auxInfo().timeCondition>;<.+>  
    } <+>
::::::  <&state.auxInfo().zsrcState.entry.code>
::::::}
::::::
::::::INLINE_Fwc void exit_<&state.stateId><&stateMethodSuffix>(<&stm.zsrcFile.variables.StateClass>* thiz)
::::::{
::::::  <&state.auxInfo().zsrcState.exit.code>
::::::}
::::::
::::::INLINE_Fwc bool trans_<&state.stateId><&stateMethodSuffix>(<&stm.zsrcFile.variables.StateClass>* thiz)
::::::{ //check all conditions of transitions, return on transition with != 0<.+>    
      if(state.transitions) {
        for(trans: state.transitions) {
          if(trans.zsrcTrans.cond) {                <+>  
                                              ::::::::  if(<&trans.zsrcTrans.cond>) {<.+>
          } elsif(trans.zsrcTrans.time) {           <+>
                                              ::::::::  if(<&stm.zsrcFile.variables.StateInstance>.timer<&state.auxInfo().rootState.stateId> <0) {<.+>
          } else {                                  <+>
                                              ::::::::  if(true) { <.+>
          }                                   
          for(exitState:trans.exitStates) {         <+>
                                                ::::::    exit_<&exitState.stateId><&stateMethodSuffix>(thiz);<.+>  
          }                                         <+>  
                                                ::::::    <&trans.zsrcTrans.code><.+>
          for(entryState:trans.entryStates) {       <+>
                                                ::::::    entry_<&entryState.stateId><&stateMethodSuffix>(thiz);<.+>  
          }                                         <+>    
                                                ::::::    return true; 
                                                ::::::  }
                                                ::::::  else <.+>
         } ##for(state.transitions)           
                                                ::::::         <+> { //action in state
                                                ::::::    return false; //no transition switched.
                                                ::::::  }<.+>
      } else { //no transition found:               <+>
                                                ::::::  return false; <.+>
      } <+>                                         
::::::}
::::::
::::::
::::::<.+>
    }##NOT stateParallel
  }
  
  <+>
::::void stepStates_<&stm.zsrcFile.variables.StateSubStruct>( <:subtext:stateMethodArguments> )
::::{ bool bTrans;                //set to true if transition has fired.
::::  int ctSwitchState = 10;     //prevent too many transitions - a endless loop
::::  do { 
::::    bTrans = false;<.+>
        call switchStates(stateComposite = stm.topState, recurs =1);
  <+>
::::  } while(bTrans && --ctSwitchState >0);
::::}
::::<.+>    
  
  
  
} ##main



sub switchStates(Obj stateComposite, Num recurs)
{
  <+>
::::<:@2*recurs>  switch(<&stm.zsrcFile.variables.StateInstance>.state<&stateComposite.stateId>) {
::::<:@2*recurs>    case 0: entry_<&stateComposite.stateDefault><&stateMethodSuffix>(thiz); //without break, do trans:
::::<.+>
                    call switchCaseState(stateComposite = stateComposite, recurs = recurs+1);
  <+>
::::<:@2*recurs>  } //switch <&stateComposite.stateId> <.+>

}








##recursively call of case for switch-state:
sub switchCaseState(Obj stateComposite, Num recurs = 0)
{
  for(state : stateComposite.aSubstates) {
    Obj zsrcState = state.auxInfo().zsrcState; 
    if(zsrcState.hasHistory || zsrcState.parallelParentState) {  
      //an innner switch-case:                                         <+>
                                                    ::::::::::<:@2*recurs>  case k<&state.stateId>_State<&stateMethodSuffix>: { <.+>
      call switchStates(stateComposite = state, recurs = recurs+1);    <+>
                                                    ::::::::::<:@2*recurs>  } break; //composite state<.+>
    } elsif(state ?instanceof classStateComposite) {                   <+>
                                                    ::::::::::<:@2*recurs>  case k<&state.stateId>_State<&stateMethodSuffix>: {<.+>      
      call switchCaseState(stateComposite = state
        , recurs = recurs+1);   //all case of composite:               <+>
                                                    ::::::::::<:@2*recurs>    bTrans |= trans_<&state.stateId><&stateMethodSuffix>(thiz); 
                                                    ::::::::::<:@2*recurs>  } break; <.+>      
    } else { //StateSimple                                        <+>
                                                    ::::::::::<:@2*recurs>  case k<&state.stateId>_State<&stateMethodSuffix>: bTrans |= trans_<&state.stateId><&stateMethodSuffix>(thiz); break;<.+>      
    }
  }
  for(state : stateComposite.aParallelstates) {
                                                                       <+>
                                                    ::::::::::<:@2*recurs>    //parallelState state<&state.stateId><.+>
    call switchStates(stateComposite = state, recurs = recurs+1);
  }
}



